<!DOCTYPE html><html>
<head>
<meta charset="utf-8">
<title>cs1.6 amxx编程 new精研教程 -- 作者:偶萤蛉(Oinling)</title>
<style>
	code {
		white-space: pre;
		color: rgb(0,0,255);
		background-color: #f1f1f1;
		font-family: Consolas, monospace;
		font-weight: bold;
	}
	.amxx-note {
		color: rgb(0,0,0);
		font-weight: normal;
	}
	.amxx-enumname {
		background: linear-gradient(to right, rgb(93,20,10), rgb(153,51,255));
		-webkit-background-clip: text;
		color: transparent;
	}
	.amxx-ds {
		background: linear-gradient(to right, rgb(111,111,107), rgb(153,51,255));
		-webkit-background-clip: text;
		color: transparent;
		font-weight: normal;
	}
	.amxx-number {
		color: rgb(0,0,0);
		font-weight: normal;
	}
	.amxx-comment {
		color: rgb(63,159,63);
		font-weight: normal;
	}
	.amxx-string {
		color: rgb(193,61,41);
		font-weight: normal;
	}
	.amxx-directive {
		color: rgb(111,111,107);
		font-weight: normal;
	}
	.amxx-tag {
		color: rgb(93,20,10);
		font-weight: normal;
	}
	.amxx-symbol {
		color: rgb(153,51,255);
		font-weight: normal;
	}
	.amxx-function {
		color: rgb(113,31,195);
		font-weight: bold;
	}
</style>
</head>
<body>

<h1>cs1.6 amxx编程 new精研教程 -- 作者:偶萤蛉(Oinling)</h1>

<h1>目录:</h1>

<code>
1:new的语法格式
2:new声明详解
2.1:new
2.2:说明符2
2.3:说明符3
2.4:说明符4
2.5:标签
2.6:符号名称
2.7:维度列表
2.8:初始化表达式
3:实例-new的基本使用方法
3.1:声明变量
3.1:与其它说明符一起使用

1:new的语法格式

new 说明符2 说明符3 说明符4 标签 符号名称 维度列表 初始化表达式;

参考:

new static stock const bool: customSymbol [2][2][2][2] =true;

new说明符用于声明变量或常量符号.

在函数体外,new可以与public static stock const说明符同时存在.

在函数体内,new可以与const说明符同时存在.

new是1号位的说明符,不论在函数体内还是体外,都必须写在左边第1位.

拥有new说明符的自定义符号,有以下特性:

1:不是函数.

2:拥有地址,数据存放在堆中(未验证).

3:初始化表达式可以是运行时表达式(仅在函数体内允许,并且这是new最特别的一点).

作为1号位的说明符,new的特性拥有最高优先级.

使用多个说明符时,若某些特性有冲突,以高优先级的为主.

2:new声明详解

2.1:new

new说明符可以写在函数体内或体外.用于声明自定义符号.

在函数体外声明的符号被称为全局变量或全局常量.可在下方任意函数体内被调用.

在函数体内声明的符号被称为局部变量或局部常量.仅能在当前或更深层的下级代码块内被调用.

2.2:说明符2

说明符2是可省略的.

在函数体外,说明符2可以是public static之一.在函数体内则不允许.

若填写public,则自定义符号可以被其他插件访问.

AMXX1.8.3以下版本中,拥有public说明符的自定义符号不能是数组.

若填写static,则自定义符号仅能在当前文件中被访问.当前插件的其它文件不能访问它.

2.3:说明符3

说明符3是可省略的.

在函数体外,说明符3可以写stock.在函数体内则不允许.

若填写stock,并且代码中没有调用声明的自定义符号,这些自定义符号会在编译时被删除.不占用内存空间.

2.4:说明符4

说明符4是可省略的.

说明符4可以写const.表示声明的自定义符号只能被初始化表达式设置默认值.接下来的代码中不能被任何运算符更改.

2.5:标签

标签是可省略的.

声明每个自定义符号都可在左边填写标签.表示该符号的运算方式或用途.

若省略标签,则默认该符号使用 _: 标签.

2.6:符号名称

符号名称是自定义的.

在AMXX1.8.3以下版本中,符号名称不得超过31个字符.

在AMXX1.8.2以上版本中,符号名称不得超过63个字符.

名称的第一个字符必须是"_ @ a至z A至Z"这四者之一.

名称的剩余字符必须是"_ @ a至z A至Z 0至9"这五者之一.

通常根据用途,给符号设定相关的英文名.

2.7:维度列表

维度列表是可省略的.

声明每个自定义符号都可在右边填写维度列表(方括号).表示该符号的数据结构.

若省略维度列表,则默认该符号仅能储存1个数值.

在AMXX1.10.0以下版本中,一个符号仅允许0至3对方括号,在AMXX1.9.0以上版本中,一个符号允许有0至4对方括号.

拥有维度列表的符号被称为数组.假设符号A拥有4对方括号,那么A是4维数组.

4维数组内存放的是3维数组,3维数组内存放的是2维数组,2维数组内存放的是1维数组,1维数组内存放的是数值.

数组内存放的对象被称作元素.而方括号内填写的数值则是表示数组的尺寸,或容量,或元素数量.

假设A的维度列表是[2][3][4][5],那么A的元素数量是2,

A的每个元素都是3维数组,每个3维数组的元素数量都是3,

3维数组的每个元素都是2维数组,每个2维数组的元素数量都是4,

2维数组的每个元素都是1维数组,每个1维数组的元素数量都是5,

1维数组的每个元素都是数值,因此每个1维数组都拥有5个数值.

方括号中的数值必须是字面量或无地址的常量,像new声明的有地址符号是不允许填入维度列表的.

方括号中的数值是可省略的.省略时,编译器会根据初始化表达式决定具体数量(这种情况下不允许省略初始化表达式).

2.8:初始化表达式

初始化表达式是可省略的.

声明每个自定义符号都可以在其维度列表右边(若没有就在符号名称右边)填写初始化表达式(以 = 符号开头的赋值表达式).

表示该符号的默认值.

若被声明的符号是数组,应赋值为字符串或数组字面量.否则应赋值为单个数值字面量.

若省略初始化表达式,则该符号的默认值为0.

初始化表达式可以用 , 符号结尾.表示接下来还要以相同的说明符继续声明自定义符号.

也可以用 ; 符号结尾,表示停止继续声明自定义符号.

通常情况下是可以省略 ; 符号的.但在检查分号模式下不允许省略 ; 符号.

3:实例-new的基本使用方法

3.1:声明变量

// 最普通的声明方式(未填写初始化表达式,因此变量的值为0)
new gVariable1;

// 连续声明多个变量,并初始化
new gVariable2 = 2, gVariable3 = 3, gVariable4 = 100;

// 声明带有标签的变量
new bool:gVariable5 = true, Float:gVariable6 = 222.0;

// 声明拥有维度列表的变量,这是尺寸为4的1维数组,拥有4个值为0的元素
new gVariable7[4];

// 声明尺寸由初始化表达式决定的1维数组变量,拥有4个元素,因此尺寸为4
new gVariable8[] = { 1, 2, 3, 4 };

// 声明尺寸为5的3维数组变量,并设定其内2维数组的尺寸为2,1维数组的尺寸为3
new Float:gVariable9[5][2][3] =
{
	{
		{ 1.0, 2.0, 3.0 },
		{ 4.0, 5.0, 6.0 },
	},
	{
		{ 7.0, 8.0, 9.0 },
		{ 10.0, 11.0, 12.0 },
	},
	{
		{ 13.0, 14.0, 15.0 },
		{ 16.0, 17.0, 18.0 },
	},
	{
		{ 19.0, 20.0, 21.0 },
		{ 22.0, 23.0, 24.0 },
	},
	{
		{ 25.0, 26.0, 27.0 },
		{ 28.0, 29.0, 30.0 },
	}
};

// 在函数体内,声明变量,并使用运行时表达式作为初始化表达式
#include amxmodx
public plugin_init()
{
	new variable1 = random(5);		// 函数只能在游戏运行时才能运行,编译时无法确认具体的值
	new Float:variable2 = 10.0 + 20.0;	// 浮点数的大部分运算符都是函数
}

3.1:与其它说明符一起使用

同时使用new const,则声明的符号是有地址的常量.

去除const的特性:"不能连续声明符号","不能是数组","必须初始化","不能用作引用参数".

保留const的特性:"不能被运算符更改".

// 声明一个有地址的常量,不能被运算符更改.
new const gConstant = 222;

同时使用new stock,则声明的符号是备用变量.

去除stock的特性:"符号数据存在栈中".

保留stock的特性:"必须在函数体外声明","未被调用则删除".

// 声明一个备用变量,接下来的代码中并未调用它,它会被删除,因此不会触发警告:"gStock符号从未被使用"
new stock gStock = 222;

同时使用new static,则声明的符号是静态变量.

去除static的特性:"符号数据存在静态数据段中".

保留static的特性:"符号仅当前文件可访问".

在函数体内,static还有一个特性是:"退出代码块不会被删除符号,下次进入代码块,符号的值依然存在".

并且失去特性:"符号仅当前文件可访问".

因此函数体内的static,所有特性都与new相悖.在函数体内,不允许符号同时拥有new static.

// 声明一个静态变量,仅当前文件可以访问它
new static gStatic = 222;

同时使用new public,则声明的符号是公共变量.

去除public的特性:"符号可以是函数".

保留public的特性:"必须在函数体外声明","符号不能是数组","符号可被其它插件或模块访问".

在AMXX1.8.2以上版本中,public不再拥有"符号不能是数组"这个特性.

// 声明一个公共变量,任何文件,插件,模块都能访问它.
new public gPublic = 222;

同时使用new public stock const或new static stock const声明自定义符号.

// 数据存于堆中的静态备用常量(实在没什么应用场景.大型插件可能会用到)
new static stock const gStaticStockConstant = 222;

// 数据存于堆中的公共备用常量(实在没什么应用场景.大型插件可能会用到)
new public stock const gPublicStockConstant = 222;

总结:

new说明符最特殊的一点是:"在函数体内,可将运行时表达式用作初始化表达式".

当new被用于函数体外,则失去这一特性.

在函数体外,使用new只会增加该符号被访问所消耗的时间.没任何好处.

</code>
</body>
</html>
