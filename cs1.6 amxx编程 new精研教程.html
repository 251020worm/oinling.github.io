<!DOCTYPE html><html>
<head>
<meta charset="utf-8">
<title>cs1.6 amxx编程 new精研教程 -- 作者:偶萤蛉(Oinling)</title>
<style>
	code {
		white-space: pre;
		color: rgb(0,0,255);
		background-color: #f1f1f1;
		font-family: Consolas, monospace;
		font-weight: bold;
	}
	.amxx-note {
		color: rgb(0,0,0);
		font-weight: normal;
	}
	.amxx-enumname {
		background: linear-gradient(to right, rgb(93,20,10), rgb(153,51,255));
		-webkit-background-clip: text;
		color: transparent;
	}
	.amxx-ds {
		background: linear-gradient(to right, rgb(111,111,107), rgb(153,51,255));
		-webkit-background-clip: text;
		color: transparent;
		font-weight: normal;
	}
	.amxx-number {
		color: rgb(0,0,0);
		font-weight: normal;
	}
	.amxx-comment {
		color: rgb(63,159,63);
		font-weight: normal;
	}
	.amxx-string {
		color: rgb(193,61,41);
		font-weight: normal;
	}
	.amxx-directive {
		color: rgb(111,111,107);
		font-weight: normal;
	}
	.amxx-tag {
		color: rgb(93,20,10);
		font-weight: normal;
	}
	.amxx-symbol {
		color: rgb(153,51,255);
		font-weight: normal;
	}
	.amxx-function {
		color: rgb(113,31,195);
		font-weight: bold;
	}
</style>
</head>
<body>

<h1>cs1.6 amxx编程 new精研教程 -- 作者:偶萤蛉(Oinling)</h1>

<h1>目录:</h1>

<code>
1:new的语法格式
2:new声明详解
2.1:new
2.2:说明符2
2.3:说明符3
2.4:说明符4
2.5:标签
2.6:符号名称
2.7:维度列表
2.8:初始化表达式
3:实例-new的基本使用方法
3.1:声明变量
3.2:与其它说明符一起使用
3.2.1:new const常量
3.2.2:new stock备用变量
3.2.3:new static静态变量
3.2.4:new public公共变量
3.2.5:new static stock const静态备用常量,new public stock const公共备用常量
3.3:总结

1:new的语法格式

new 说明符2 说明符3 说明符4 标签 符号名称 维度列表 初始化表达式;

参考:

new static stock const bool: customSymbol [2][2][2][2] =true;

new说明符用于声明自定义符号(变量).

在函数体外,new可以与public static stock const说明符同时存在.

在函数体内,new可以与const说明符同时存在.

new是1号位的说明符,不论在函数体内还是体外,都必须写在左边第1位.

new说明符有以下特性:

1:被声明的自定义符号(变量)不能是函数.

2:被声明的自定义符号(变量)拥有地址.可通过地址进行查改.

3:在函数体内,可将"运行时表达式"用作自定义符号(变量)的"初始化表达式".

相对其它说明符,new的第3个特性是独一无二的.

作为1号位的说明符,new的特性拥有最高优先级.

使用多个说明符时,若某些特性有冲突,以高优先级的为主.

2:new声明详解

2.1:new

new说明符可以写在函数体内或体外.用于声明自定义符号(变量).

在函数体外声明的符号被称为"全局变量".可在下方任意函数体内被调用.

在函数体内声明的符号被称为"局部变量".仅能在当前代码块,与其内层代码块中被调用.

2.2:说明符2

说明符2是可省略的.

在函数体外,说明符2可以是public static之一.在函数体内则不允许.

若填写public,则自定义符号可以被其他插件访问.

AMXX1.8.3以下版本中,拥有public说明符的自定义符号不能是数组.

若填写static,则自定义符号仅能在当前文件中被访问.当前插件的其它文件不能访问它.

2.3:说明符3

说明符3是可省略的.

说明符3只能写stock,这是唯一的3号位说明符.

若填写stock,编译器不会警告符号(变量)未被调用.

若符号(变量)未被调用,则编译时,不会将符号(变量)写入amxx文件,不会占用内存空间.

2.4:说明符4

说明符4是可省略的.

说明符4可以写const.表示声明的自定义符号只能被初始化表达式设置默认值.接下来的代码中不能被任何运算符更改.

2.5:标签

标签是可省略的.

声明每个自定义符号都可在左边填写标签.表示该符号的运算方式或用途.

若省略标签,则默认该符号使用 _: 标签.

2.6:符号名称

符号名称是自定义的,命名时应遵守符号命名规则.

在AMXX1.8.3以下版本中,符号名称不得超过31个字符.

在AMXX1.8.2以上版本中,符号名称不得超过63个字符.

名称的第一个字符必须是"_ @ a至z A至Z"这四者之一.

名称的剩余字符必须是"_ @ a至z A至Z 0至9"这五者之一.

通常根据用途,给符号设定相关的英文名.

不得与保留词或用户声明的其它符号重名.

2.7:维度列表

维度列表是可省略的.

声明每个自定义符号都可在右边填写维度列表(方括号).表示该符号的数据结构.

若省略维度列表,则默认该符号仅能储存1个数值.

在AMXX1.10.0以下版本中,一个符号仅允许0至3对方括号,在AMXX1.9.0以上版本中,一个符号允许有0至4对方括号.

拥有维度列表的符号被称为数组.假设符号A拥有4对方括号,那么A是4维数组.

4维数组内存放的是3维数组,3维数组内存放的是2维数组,2维数组内存放的是1维数组,1维数组内存放的是数值.

数组内存放的对象被称作元素.而方括号内填写的数值则是表示数组的尺寸,或容量,或元素数量.

假设A的维度列表是[2][3][4][5],那么A的元素数量是2,

A的每个元素都是3维数组,每个3维数组的元素数量都是3,

3维数组的每个元素都是2维数组,每个2维数组的元素数量都是4,

2维数组的每个元素都是1维数组,每个1维数组的元素数量都是5,

1维数组的每个元素都是数值,因此每个1维数组都拥有5个数值.

方括号中的数值必须是字面量或无地址的常量,像new声明的有地址符号是不允许填入维度列表的.

方括号中的数值是可省略的.省略时,编译器会根据初始化表达式决定具体数量(这种情况下不允许省略初始化表达式).

2.8:初始化表达式

初始化表达式是可省略的.

声明每个自定义符号都可以在其维度列表右边(若没有就在符号名称右边)填写初始化表达式(以 = 符号开头的赋值表达式).

表示该符号的默认值.

若被声明的符号是数组,应赋值为字符串或数组字面量.否则应赋值为单个数值字面量.

若省略初始化表达式,则该符号的默认值为0.

初始化表达式可以用 , 符号结尾.表示接下来还要以相同的说明符继续声明自定义符号.

也可以用 ; 符号结尾,表示停止继续声明自定义符号.

通常情况下是可以省略 ; 符号的.但在检查分号模式下不允许省略 ; 符号.

3:实例-new的基本使用方法

3.1:声明变量

// 最普通的声明方式(未填写初始化表达式,因此变量的值为0)
new gVariable1;

// 连续声明多个变量,并初始化
new gVariable2 = 2, gVariable3 = 3, gVariable4 = 100;

// 声明带有标签的变量
new bool:gVariable5 = true, Float:gVariable6 = 222.0;

// 声明拥有维度列表的变量,这是尺寸为4的1维数组,拥有4个值为0的元素
new gVariable7[4];

// 声明尺寸由初始化表达式决定的1维数组变量,拥有4个元素,因此尺寸为4
new gVariable8[] = { 1, 2, 3, 4 };

// 声明尺寸为5的3维数组变量,并设定其内2维数组的尺寸为2,1维数组的尺寸为3
new Float:gVariable9[5][2][3] =
{
	{
		{ 1.0, 2.0, 3.0 },
		{ 4.0, 5.0, 6.0 },
	},
	{
		{ 7.0, 8.0, 9.0 },
		{ 10.0, 11.0, 12.0 },
	},
	{
		{ 13.0, 14.0, 15.0 },
		{ 16.0, 17.0, 18.0 },
	},
	{
		{ 19.0, 20.0, 21.0 },
		{ 22.0, 23.0, 24.0 },
	},
	{
		{ 25.0, 26.0, 27.0 },
		{ 28.0, 29.0, 30.0 },
	}
};

// 在函数体内,声明变量,并使用运行时表达式作为变量的初始化表达式
#include amxmodx
public plugin_init()
{
	new variable1 = random(5);		// 函数只能在游戏运行时才能运行,编译时无法确认具体的值
	new Float:variable2 = 10.0 + 20.0;	// 浮点数的大部分运算符都是函数
}

3.2:与其它说明符一起使用

3.2.1:new const常量

同时使用new const,则声明的符号是有地址的常量.

去除const的特性:

"不能连续声明常量",
"声明的常量不能是数组",
"声明的常量必须初始化",
"声明的常量不能用作引用参数".

保留const的特性:

"声明的常量不能被运算符更改".

// 声明一个有地址的常量,不能被运算符更改.
new const gConstant = 222;

3.2.2:new stock备用变量

同时使用new stock,则声明的符号是备用变量.

去除stock的特性:

未知.

保留stock的特性:

"说明符仅允许在函数体外使用",
"不警告符号未被使用,不将未被使用的符号编译到amxx文件".

目前看来,同时使用new stock与单独使用stock没什么不同.

new说明符允许将运行时表达式用作变量的初始化表达式.

但在函数体外无法表现出这个特性.AMXX不支持在函数体外运行函数.

因此,目前看来,同时使用new stock并没有什么用处.

// 声明一个备用变量,接下来的代码中并未调用它,则不被写入amxx文件,因此不会触发警告:"gStock符号从未被使用"
new stock gStock = 222;

3.2.3:new static静态变量

同时使用new static,则声明的符号是静态变量.

去除static的特性:

"可声明函数或变量".

保留static的特性:

"被声明的函数或全局变量,仅当前文件可访问.其它文件,插件,模块都无法访问",
"被声明的局部变量,不会被销毁.因此,下次进入代码块,依然能访问变量最后一次储存的值".

在函数体内,不允许符号同时拥有new static说明符.

在函数体外,目前看来,同时使用new static与单独使用static没什么不同.

new说明符允许将运行时表达式用作变量的初始化表达式.

但在函数体外无法表现出这个特性.AMXX不支持在函数体外运行函数.

因此,目前看来,同时使用new static并没有什么用处.

// 声明一个静态变量,仅当前文件可以访问它
new static gStatic = 222;

3.2.4:new public公共变量

同时使用new public,则声明的符号是公共变量.

去除public的特性:

"可声明函数或变量".

保留public的特性:

"仅允许在函数体外使用",
"被声明的变量不能是数组",
"被声明的函数或变量可被其它文件,插件,模块访问".

在AMXX1.8.2以上版本中,public不再拥有"被声明的变量不能是数组"这个特性.

在函数体外,目前看来,同时使用new public与单独使用public没什么不同.

new说明符允许将运行时表达式用作变量的初始化表达式.

但在函数体外无法表现出这个特性.AMXX不支持在函数体外运行函数.

因此,目前看来,同时使用new public并没有什么用处.

// 声明一个公共变量,任何文件,插件,模块都能访问它.
new public gPublic = 222;

3.2.5:new static stock const静态备用常量,new public stock const公共备用常量

同时使用new public stock const或new static stock const声明自定义符号.

// 静态备用常量(实在没什么应用场景.大型插件可能会用到)
new static stock const gStaticStockConstant = 222;

// 公共备用常量(实在没什么应用场景.大型插件可能会用到)
new public stock const gPublicStockConstant = 222;

3.3:总结

new说明符最特殊的一点是:"在函数体内,可将运行时表达式用变量的作初始化表达式".

当new被用于函数体外,则失去这一特性(AMXX不支持函数体外的运行时表达式).

由于new public static stock声明的符号都拥有地址,目前看来,new与public static stock一起使用,不会增加任何好处.

但可以与const一起使用.声明有地址的常量,使该常量可以通过地址被更改.或是声明有维度列表的数组常量.

在AMXX1.8.2以上版本中,amxconst.inc文件内便声明了这种有地址常量.

虽然编译时该常量的值为0,但插件运行后,由模块更改它的值.

插件访问这个常量得到的是被更改后的值.

// 服务器最大客户端数量,由模块设定这个常量的值.
public stock const MaxClients;

</code>
</body>
</html>