<!DOCTYPE html><html>
<head>
<meta charset="utf-8">
<title>cs1.6 amxx编程 for精研教程 -- 作者:偶萤蛉(Oinling)</title>
<style>
	code {
		white-space: pre;
		color: rgb(0,0,255);
		background-color: #f1f1f1;
		font-family: Consolas, monospace;
		font-weight: bold;
	}
	.amxx-note {
		color: rgb(0,0,0);
		font-weight: normal;
	}
	.amxx-enumname {
		background: linear-gradient(to right, rgb(93,20,10), rgb(153,51,255));
		-webkit-background-clip: text;
		color: transparent;
	}
	.amxx-ds {
		background: linear-gradient(to right, rgb(111,111,107), rgb(153,51,255));
		-webkit-background-clip: text;
		color: transparent;
		font-weight: normal;
	}
	.amxx-number {
		color: rgb(0,0,0);
		font-weight: normal;
	}
	.amxx-comment {
		color: rgb(63,159,63);
		font-weight: normal;
	}
	.amxx-string {
		color: rgb(193,61,41);
		font-weight: normal;
	}
	.amxx-directive {
		color: rgb(111,111,107);
		font-weight: normal;
	}
	.amxx-tag {
		color: rgb(93,20,10);
		font-weight: normal;
	}
	.amxx-symbol {
		color: rgb(153,51,255);
		font-weight: normal;
	}
	.amxx-function {
		color: rgb(113,31,195);
		font-weight: bold;
	}
</style>
</head>
<body>

<h1>cs1.6 amxx编程 for精研教程 -- 作者:偶萤蛉(Oinling)</h1>

<h1>目录:</h1>

<p><a href="#click1">1:for循环的语法格式</a></p>

<p><a href="#click2">2:for表达式详解</a></p>

<p><a href="#click2_1">2.1:for</a></p>

<p><a href="#click2_2">2.2:表达式列表入口</a></p>

<p><a href="#click2_3">2.3:表达式1</a></p>

<p><a href="#click2_4">2.4:表达式2</a></p>

<p><a href="#click2_5">2.5:表达式3</a></p>

<p><a href="#click2_6">2.6:表达式列表出口</a></p>

<p><a href="#click2_7">2.7:循环体入口</a></p>

<p><a href="#click2_8">2.8:循环体出口</a></p>

<p><a href="#click3">3:实例-循环基本使用方法</a></p>

<p><a href="#click3_1">3.1:省略了表达式1/2/3的死循环</a></p>

<p><a href="#click3_2">3.2:正向循环</a></p>

<p><a href="#click3_3">3.3:反向循环</a></p>

<p><a href="#click3_4">3.4:continue跳过循环</a></p>

<p><a href="#click3_5">3.5:break停止循环</a></p>

<p><a href="#click3_6">3.6:return退出函数</a></p>

<p><a href="#click3_7">3.7:goto跳出循环</a></p>

<p><a href="#click3_8">3.8:破坏循环条件</a></p>

<p><a href="#click4">4:实例-循环实际应用</a></p>

<p><a href="#click4_1">4.1:计算数量</a></p>

<p><a href="#click4_2">4.2:收集满足条件的对象</a></p>

<p><a href="#click4_3">4.3:找最低值(寻找最近的活者)</a></p>

<p><a href="#click4_4">4.3:找最高值(寻找最远的活者)</a></p>

<p><a href="#click5">5:将for语句的代码执行流程打印到控制台</a></p>

<p><h1 id="click1">1:for循环的语法格式</h1></p>

<p><code>for 表达式列表入口 表达式1; 表达式2; 表达式3 表达式列表出口
循环体入口
循环体出口</code></p>

<p>参考:</p>

<p><code>for (new <span class="amxx-symbol">num</span>; <span class="amxx-symbol">num</span> < <span class="amxx-number">10</span>; <span class="amxx-symbol">num</span>++)
{
}</code></p>

<p><h1 id="click2">2:for表达式详解</h1></p>

<p>for循环的主要功能是重复执行循环体内的代码.</p>

<p>在循环过程中,开发者可设计多次重复的相同操作,也可根据不断改变的变量,做一些不同的操作.</p>

<p>熟练使用循环可简化某些相似度极高但参数有细微变化的代码.</p>

<p>for表达式内的代码执行顺序:</p>

<p>表达式1最先执行,仅执行一次.然后前往表达式2.</p>

<p>表达式2执行之后若等于0,前往循环体出口(停止循环).否则前往循环体入口,进入内部执行代码.</p>

<p>循环体内代码执行之后,前往表达式3.</p>

<p>表达式3执行完毕后,前往表达式2,开始下一轮循环.</p>

<p>表达式1通常用于声明变量并初始化.因此表达式1也可称呼为:初始化表达式.</p>

<p>表达式2通常用于判断变量是否等于0.因此表达式2也可称呼为:条件表达式.</p>

<p>表达式3通常用于控制变量自增或自减,使表达式2有机会等于0.因此表达式3也可称呼为:迭代表达式.</p>

<p>循环停止之后,表达式1和循环体内用<code>new</code>或<code>new const</code>声明的符号会被销毁,因此循环体出口下方代码不允许调用这些符号.</p>

<p>用<code>static</code>或<code>static const</code>声明的符号虽然不会被销毁,但受到作用域限制,不允许被循环体出口下方代码调用.</p>

<p><h2 id="click2_1">2.1:for</h2></p>

<p><code>for</code>只能在函数体内使用.使代码不再是自上而下运行,而是在指定规则下多次重复一个区域内的代码.</p>

<p><h2 id="click2_2">2.2:表达式列表入口</h2></p>

<p>表达式列表入口用<code> ( </code>符号表示.</p>

<p><h2 id="click2_3">2.3:表达式1</h2></p>

<p>表达式1是可省略的.</p>

<p>若不省略,可填写<code>new</code>或<code>new const</code>声明符号.也可调用自定义符号做运算.</p>

<p>表达式1必须使用<code> ; </code>符号结尾.用于区分表达式1和表达式2.</p>

<p>不允许填写除了<code>new</code>与<code>new const</code>以外的说明符,以及所有控制流保留词.</p>

<p><h2 id="click2_4">2.4:表达式2</h2></p>

<p>表达式2是可省略的.</p>

<p>若不省略,可填写一个或数个条件表达式.</p>

<p>表达式2必须使用<code> ; </code>符号结尾.用于区分表达式2和表达式3.</p>

<p>不允许填写所有说明符,控制流保留词.</p>

<p><h2 id="click2_5">2.5:表达式3</h2></p>

<p>表达式3是可省略的.</p>

<p>若不省略,可调用自定义符号做运算.不允许填写说明符,控制流保留词.</p>

<p>表达式3不能使用<code> ; </code>符号结尾.它已经是最后一个表达式.</p>

<p><h2 id="click2_6">2.6:表达式列表出口</h2></p>

<p>表达式列表出口用<code> ) </code>符号表示.</p>

<p><h2 id="click2_7">2.7:循环体入口</h2></p>

<p>循环体入口用<code> { </code>符号表示.</p>

<p>循环体出入口是可省略的,若省略,则循环体内仅允许填写一条语句.</p>

<p><h2 id="click2_8">2.8:循环体出口</h2></p>

<p>循环体出口用<code> } </code>符号表示.</p>

<p>循环体出入口是可省略的,若省略,则循环体内仅允许填写一条语句.</p>

<p><h1 id="click3">3:实例-循环基本使用方法</h1></p>

<p><h2 id="click3_1">3.1:省略了表达式1/2/3的死循环</h2></p>

<p>使用以下代码,将导致<span class="amxx-function">LogOneLine</span>函数无限重复运行.游戏无法退出函数,无法做其它事情,无法刷新下一帧.</p>

<code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	new <span class="amxx-symbol">counter</span>, <span class="amxx-function">timer</span> = <span class="amxx-function">tickcount</span>();
	for (;;)
	{
		<span class="amxx-function">LogOneLine</span>(<span class="amxx-string">"循环次数:%011d, 循环持续时间:%08.2f秒"</span>, ++<span class="amxx-function">counter</span>, <span class="amxx-function">float</span>(<span class="amxx-function">tickcount</span>() - <span class="amxx-function">timer</span>) / <span class="amxx-number">1000.0</span>);
	}
}
<span class="amxx-comment">/**
 * 写一行字到"cstrike/addons/amxmodx/logs/L今年今月今日.log".
 *
 * @param formatString	要写入的文字,可使用格式占位符:%b %c %d %i %u %f %X %x %a %s %L %l %N %n %%
 * @param ...		可根据格式占位符的需求填写不限量的引用参数.
 *
 * @return		返回实际写入的字节数
 * @error		未填写格式占位符所需的参数
*/</span>
static <span class="amxx-function">LogOneLine</span>(const <span class="amxx-symbol">formatString</span>[], <span class="amxx-tag">any:</span>...)
{
	static <span class="amxx-symbol">buffer</span>[<span class="amxx-number">256</span>];
	<span class="amxx-function">vformat</span>(<span class="amxx-symbol">buffer</span>, <span class="amxx-function">charsmax</span>(<span class="amxx-symbol">buffer</span>), <span class="amxx-symbol">formatString</span>, <span class="amxx-number">2</span>);
	
	static <span class="amxx-symbol">filePathLength</span>, <span class="amxx-symbol">filePath</span>[<span class="amxx-number">64</span>];
	<span class="amxx-symbol">filePathLength</span> = <span class="amxx-function">get_localinfo</span>(<span class="amxx-string">"amx_logdir"</span>, <span class="amxx-symbol">filePath</span>, <span class="amxx-function">charsmax</span>(<span class="amxx-symbol">filePath</span>));
	<span class="amxx-symbol">filePathLength</span> += <span class="amxx-function">get_time</span>(<span class="amxx-string">"/L%Y%m%d.log"</span>, <span class="amxx-symbol">filePath</span>[<span class="amxx-symbol">filePathLength</span>], <span class="amxx-function">charsmax</span>(<span class="amxx-symbol">filePath</span>) - <span class="amxx-symbol">filePathLength</span>);
	if (<span class="amxx-function">file_exists</span>(<span class="amxx-symbol">filePath</span>)) <span class="amxx-function">delete_file</span>(<span class="amxx-symbol">filePath</span>);
	
	return <span class="amxx-function">log_amx</span>(<span class="amxx-symbol">buffer</span>);
}</code>

<p>强行关闭游戏后,可以打开"cstrike/addons/amxmodx/logs/L今年今月今日.log"文件,查阅循环次数与持续时间(可能会是空白,再试几次死循环就有文字了).</p>

<p>该例子告诉我们,代码运行期间,游戏不会刷新下一帧,任何玩家都别想做事情了.</p>

<p>因此,使用循环时,一定要避免死循环.比如在表达式2位置填写条件表达式.</p>

<p><h2 id="click3_2">3.2:正向循环</h2></p>

<p>使用以下代码,在进入游戏,载入地图,打开控制台之后,可以看见server_print函数被重复运行了10次.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	for (new <span class="amxx-symbol">number</span>; <span class="amxx-symbol">number</span> < <span class="amxx-number">10</span>; <span class="amxx-symbol">number</span>++)
	{
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>);
	}
}</code></p>

<p>打印结果:</p>

<p><code><span class="amxx-note">[AMXX]number = 0
[AMXX]number = 1
[AMXX]number = 2
[AMXX]number = 3
[AMXX]number = 4
[AMXX]number = 5
[AMXX]number = 6
[AMXX]number = 7
[AMXX]number = 8
[AMXX]number = 9</span></code></p>

<p><span class="amxx-symbol">number</span>的初始值为0,每次小于10都打印一次,然后自增1.因此打印结果从0开始,直至9.总共10次.</p>

<p>最终,因为<span class="amxx-symbol">number</span>等于10,不满足表达式2的条件(小于10),停止了循环.</p>

<p><h2 id="click3_3">3.3:反向循环</h2></p>

<p>使用以下代码,在进入游戏,载入地图,打开控制台之后,可以看见server_print函数被重复运行了10次.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	for (new <span class="amxx-symbol">number</span> = <span class="amxx-number">10</span>; <span class="amxx-symbol">number</span>; <span class="amxx-symbol">number</span>--)
	{
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>);
	}
}</code></p>

<p>打印结果:</p>

<p><code><span class="amxx-note">[AMXX]number = 10
[AMXX]number = 9
[AMXX]number = 8
[AMXX]number = 7
[AMXX]number = 6
[AMXX]number = 5
[AMXX]number = 4
[AMXX]number = 3
[AMXX]number = 2
[AMXX]number = 1</span></code></p>

<p><span class="amxx-symbol">number</span>的初始值为10,每次非0都打印一次,然后自减1.因此打印结果从10开始,直至1.总共10次.</p>

<p>最终,因为<span class="amxx-symbol">number</span>等于0,不满足表达式2的条件(非0),停止了循环.</p>

<p>若想让循环体内访问<span class="amxx-symbol">number</span>的值时得到的是9至0,可以这么做:</p>

<p><code>for (new <span class="amxx-symbol">number</span> = <span class="amxx-number">10</span>; <span class="amxx-symbol">number</span>--;)
{
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>);
}</code></p>

<p>表达式2会先检查<span class="amxx-symbol">number</span>非0,再使<span class="amxx-symbol">number</span>自减1,再进入循环体执行代码(或停止循环).</p>

<p>也就是说,是否进入循环体,由自减前的<span class="amxx-symbol">number</span>决定,而不是由自减后的<span class="amxx-symbol">number</span>决定.</p>

<p>若想让循环体内访问<span class="amxx-symbol">number</span>的值时得到的是9至0,可以这么做:</p>

<p><code>for (new <span class="amxx-symbol">number</span> = <span class="amxx-number">10</span>; <span class="amxx-symbol">number</span>--;)
{
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>);
}</code></p>

<p>表达式2会先检查<span class="amxx-symbol">number</span>非0,再使<span class="amxx-symbol">number</span>自减1,再进入循环体执行代码(或停止循环).</p>

<p>也就是说,是否进入循环体,由自减前的<span class="amxx-symbol">number</span>决定,而不是由自减后的<span class="amxx-symbol">number</span>决定.</p>

<p>打印结果:</p>

<p><code><span class="amxx-note">[AMXX]number = 9
[AMXX]number = 8
[AMXX]number = 7
[AMXX]number = 6
[AMXX]number = 5
[AMXX]number = 4
[AMXX]number = 3
[AMXX]number = 2
[AMXX]number = 1
[AMXX]number = 0
</span></code></p>

<p><h2 id="click3_4">3.4:continue跳过循环</h2></p>

<p>循环体内,可使用<code>continue</code>保留词.在<code>for</code>的循环体中,它的作用是立即前往表达式3.</p>

<p>因此,一旦运行了<code>continue</code>,在它下方的代码不会运行.</p>

<p><code>continue</code>常常与<code>if case default</code>等语句一起使用.只要满足某些条件,便跳过循环体中剩余部分的代码.</p>

<p>以下代码,可展示<code>continue</code>跳过循环体中剩余部分代码的功能:</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]第1轮循环,访问数值0至9:"</span>);
	for (new <span class="amxx-symbol">number</span>; <span class="amxx-symbol">number</span> < <span class="amxx-number">10</span>; <span class="amxx-symbol">number</span>++)
	{
		if (<span class="amxx-symbol">number</span> == <span class="amxx-number">1</span>) continue;
		if (<span class="amxx-symbol">number</span> == <span class="amxx-number">3</span>) continue;
		if (<span class="amxx-symbol">number</span> == <span class="amxx-number">5</span>) continue;
		if (<span class="amxx-symbol">number</span> == <span class="amxx-number">7</span>) continue;
		if (<span class="amxx-symbol">number</span> == <span class="amxx-number">9</span>) continue;
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>);
	}
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]第2轮循环,访问数值0至19:"</span>);
	for (new <span class="amxx-symbol">number</span>; <span class="amxx-symbol">number</span> < <span class="amxx-number">20</span>; <span class="amxx-symbol">number</span>++)
	{
		switch (<span class="amxx-symbol">number</span>)
		{
			case <span class="amxx-number">3</span> .. <span class="amxx-number">18</span>: continue;
		}
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>);
	}
}</code></p>

<p>打印结果:</p>

<p><code><span class="amxx-note">[AMXX]第1轮循环,访问数值0至9:
[AMXX]number = 0
[AMXX]number = 2
[AMXX]number = 4
[AMXX]number = 6
[AMXX]number = 8
[AMXX]第2轮循环,访问数值0至19:
[AMXX]number = 0
[AMXX]number = 1
[AMXX]number = 2
[AMXX]number = 19</span></code></p>

<p>在第1轮循环中.由于<span class="amxx-symbol">number</span>满足等于1 3 5 7 9的条件,因此游戏中并未执行<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>)语句.</p>

<p>在第2轮循环中,由于<span class="amxx-symbol">number</span>满足等于3至18的条件,因此游戏中并未执行<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>)语句.</p>

<p>以下代码可展示<code>continue</code>立即前往表达式3的特性,在它下方的代码是不会运行的.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	for (new <span class="amxx-symbol">number</span>; <span class="amxx-symbol">number</span> < <span class="amxx-number">10</span>; <span class="amxx-symbol">number</span>++)
	{
		if (<span class="amxx-symbol">number</span> < <span class="amxx-number">5</span>)
		{
			<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number < 5, continue"</span>);
			continue;
			<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]测试"</span>);	<span class="amxx-comment">// 编译器警告:这一行的代码无法访问</span>
		}
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>);
	}
}</code></p>

<p>打印结果:</p>

<p><code><span class="amxx-note">[AMXX]number < 5, continue
[AMXX]number < 5, continue
[AMXX]number < 5, continue
[AMXX]number < 5, continue
[AMXX]number < 5, continue
[AMXX]number = 5
[AMXX]number = 6
[AMXX]number = 7
[AMXX]number = 8
[AMXX]number = 9</span></code></p>

<p>从打印结果可看出,<code>continue</code>的上一行代码确实执行了,那么接下来就会执行<code>continue</code>.</p>

<p>而<code>continue</code>下一行的<span class="amxx-string">"[AMXX]测试"</span>并未被打印出来,说明<code>continue</code>执行完毕后并未再向下执行代码.</p>

<p>从打印结果可看到下一行的数值在递增,进一步证明了<code>continue</code>会直接跳转至表达式3,执行<span class="amxx-symbol">number</span>的自增运算.</p>

<p>需要注意,如果是在多层<code>for</code>循环体内使用<code>continue</code>保留词,只会前往最深层的表达式3.</p>

<p>可用以下代码进行测试:</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	for (new <span class="amxx-symbol">number</span>; <span class="amxx-symbol">number</span> < <span class="amxx-number">3</span>; <span class="amxx-symbol">number</span>++)
	{
		for (new <span class="amxx-symbol">n2</span>; <span class="amxx-symbol">n2</span> < <span class="amxx-number">3</span>; <span class="amxx-symbol">n2</span>++)
		{
			if (<span class="amxx-symbol">n2</span> == <span class="amxx-number">1</span>) continue;
			<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d, n2 = %d"</span>, <span class="amxx-symbol">number</span>, <span class="amxx-symbol">n2</span>);
		}
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>);
	}
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]循环-结束!"</span>);
}</code></p>

<p>打印结果:</p>

<p><code><span class="amxx-note">[AMXX]number = 0, n2 = 0
[AMXX]number = 0, n2 = 2
[AMXX]number = 0
[AMXX]number = 1, n2 = 0
[AMXX]number = 1, n2 = 2
[AMXX]number = 1
[AMXX]number = 2, n2 = 0
[AMXX]number = 2, n2 = 2
[AMXX]number = 2
[AMXX]循环-结束!</span></code></p>

<p>可以看到,<span class="amxx-symbol">number</span>等于0至2,一个都没少.</p>

<p>而<span class="amxx-symbol">n2</span>等于0至2的循环中,只有<span class="amxx-symbol">n2</span> = 1被跳过了.</p>

<p>这证明了<code>continue</code>只作用于其所在循环体中,最深层的循环.</p>

<p><h2 id="click3_5">3.5:break停止循环</h2></p>

<p>循环体内,可使用<code>break</code>保留词.它能停止任何循环语句.</p>

<p>一旦运行了<code>break</code>,在它下方的剩余代码不会被运行.</p>

<p><code>break</code>常常与<code>if case default</code>等语句一起使用.只要满足某些条件,便立即停止循环.</p>

<p>以下代码,可展示<code>break</code>停止循环的功能:</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	new <span class="amxx-symbol">number</span>
	for (; <span class="amxx-symbol">number</span> < <span class="amxx-number">10</span>; <span class="amxx-symbol">number</span>++)
	{
		if (<span class="amxx-symbol">number</span> == <span class="amxx-number">5</span>)
		{
			<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d,满足break条件."</span>, <span class="amxx-symbol">number</span>);
			break;
		}
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>);
	}
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]循环-结束! number = %d"</span>, <span class="amxx-symbol">number</span>);
}</code></p>

<p>打印结果:</p>

<p><code><span class="amxx-note">[AMXX]number = 0
[AMXX]number = 1
[AMXX]number = 2
[AMXX]number = 3
[AMXX]number = 4
[AMXX]number = 5,满足break条件.
[AMXX]循环-结束! number = 5</span></code></p>

<p>可见,<code>break</code>一旦执行,会直接停止循环.从最后一个打印可看出,<span class="amxx-symbol">number</span>在<code>break</code>之前与之后都等于5,说明<code>break</code>不像<code>continue</code>会前往表达式3,而是直接停止循环.</p>

<p>需要注意,如果是在多层<code>for</code>循环体内使用<code>break</code>保留词,只会停止最深层的<code>for</code>循环.</p>

<p>可用以下代码进行测试:</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	for (new <span class="amxx-symbol">number</span>; <span class="amxx-symbol">number</span> < <span class="amxx-number">3</span>; <span class="amxx-symbol">number</span>++)
	{
		for (new <span class="amxx-symbol">n2</span>; <span class="amxx-symbol">n2</span> < <span class="amxx-number">3</span>; <span class="amxx-symbol">n2</span>++)
		{
			if (<span class="amxx-symbol">n2</span> == <span class="amxx-number">1</span>) break;
			<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d, n2 = %d"</span>, <span class="amxx-symbol">number</span>, <span class="amxx-symbol">n2</span>);
		}
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>);
	}
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]循环-结束!"</span>);
}</code></p>

<p>打印结果:</p>

<p><code><span class="amxx-note">
[AMXX]number = 0, n2 = 0
[AMXX]number = 0
[AMXX]number = 1, n2 = 0
[AMXX]number = 1
[AMXX]number = 2, n2 = 0
[AMXX]number = 2
[AMXX]循环-结束!</span></code></p>

<p>可以看到,<span class="amxx-symbol">number</span>等于0至2,一个都没少.</p>

<p>而<span class="amxx-symbol">n2</span>等于0至2的循环中,只有<span class="amxx-symbol">n2</span> = 0被打印出来.</p>

<p>这证明了<code>break</code>只作用于其所在循环体中,最深层的循环.</p>

<p><h2 id="click3_6">3.6:return退出函数</h2></p>

<p>循环体内可以使用<code>return</code>保留词,<code>return</code>的作用是立即退出函数,回到调用函数的位置.</p>

<p>这一点,即便是在循环体内也不会改变.</p>

<p>以下代码,展示<code>return</code>停止循环,退出函数的功能.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]准备调用ForTester()函数."</span>);
	<span class="amxx-function">ForTester</span>();
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]已返回调用ForTester()的位置."</span>);
}
static <span class="amxx-function">ForTester</span>()
{
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]已进入ForTester()内部,执行各种代码."</span>);
	for (new <span class="amxx-symbol">number</span>; <span class="amxx-symbol">number</span> < <span class="amxx-number">10</span>; <span class="amxx-symbol">number</span>++)
	{
		if (<span class="amxx-symbol">number</span> == <span class="amxx-number">5</span>)
		{
			return;
			<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]return下方的代码."</span>);	<span class="amxx-comment">// 编译器警告:无法访问这一行的代码.</span>
		}
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>);
	}
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]循环-结束!"</span>);
}</code></p>

<p>打印结果:</p>

<p><code><span class="amxx-note">[AMXX]准备调用ForTester()函数.
[AMXX]已进入ForTester()内部,执行各种代码.
[AMXX]number = 0
[AMXX]number = 1
[AMXX]number = 2
[AMXX]number = 3
[AMXX]number = 4
[AMXX]已返回调用ForTester()的位置.</span></code></p>

<p>从打印结果可看出,在满足<span class="amxx-symbol">number</span>等于5这个条件后,<code>return</code>下方的3个打印全都没有执行,而是直接打印了<span class="amxx-string">"[AMXX]已返回调用ForTester()的位置."</span>.</p>

<p>这证明了<code>return</code>不但停止了循环(5至9统统未被打印),而且还直接退出了函数,回到调用函数的位置.</p>

<p><h2 id="click3_7">3.7:goto跳出循环</h2></p>

<p>循环体内可以使用<code>goto</code>保留词,<code>goto</code>的作用是立即前往函数体内的某个标记位置.</p>

<p>以下代码,展示<code>goto</code>跳出循环的功能.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]准备调用ForTester()函数."</span>);
	<span class="amxx-function">ForTester</span>();
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]已返回调用ForTester()的位置."</span>);
}
static <span class="amxx-function">ForTester</span>()
{
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]已进入ForTester()内部,执行各种代码."</span>);
	for (new <span class="amxx-symbol">number</span>; <span class="amxx-symbol">number</span> < <span class="amxx-number">10</span>; <span class="amxx-symbol">number</span>++)
	{
		if (<span class="amxx-symbol">number</span> == <span class="amxx-number">5</span>)
		{
			goto <span class="amxx-symbol">Label@@@@@</span>;	<span class="amxx-comment">// 跳转至Label@@@@@标记所在位置.</span>
			<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]goto下方的代码."</span>, <span class="amxx-symbol">number</span>);
		}
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>);
	}
	<span class="amxx-symbol">Label@@@@@:</span>	<span class="amxx-comment">// 声明一个名叫Label@@@@@的标记,使goto可以跳转到这里.</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]循环-结束!"</span>);
}</code></p>

<p>打印结果:</p>

<p><code><span class="amxx-note">[AMXX]准备调用ForTester()函数.
[AMXX]已进入ForTester()内部,执行各种代码.
[AMXX]number = 0
[AMXX]number = 1
[AMXX]number = 2
[AMXX]number = 3
[AMXX]number = 4
[AMXX]循环-结束!
[AMXX]已返回调用ForTester()的位置.</span></code></p>

<p>从打印结果可看出,在满足<span class="amxx-symbol">number</span>等于5这个条件后,<span class="amxx-string">"[AMXX]goto下方的代码."</span>并未被打印,而是直接打印了<span class="amxx-string">"[AMXX]循环-结束!"</span>.</p>

<p>这证明了<code>goto</code>直接跳出了循环(5至9统统未被打印).</p>

<p>如果想要同时停止多层循环,利用<code>goto</code>直接跳出,会是个不错的方法.</p>

<p><h2 id="click3_8">3.8:破坏循环条件</h2></p>

<p>在某些情况下,我们可以直接更改表达式2中所使用的变量,另其计算结果为0,已达到停止循环的效果.</p>

<p>这种方法不像<code>continue</code>或<code>break</code>一样会忽略循环体中剩余的代码,因此比较罕见.</p>

<p>如下所示:</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	for (new <span class="amxx-symbol">number</span>; <span class="amxx-symbol">number</span> < <span class="amxx-number">3</span>; <span class="amxx-symbol">number</span>++)
	{
		for (new <span class="amxx-symbol">n2</span>; <span class="amxx-symbol">n2</span> < <span class="amxx-number">3</span>; <span class="amxx-symbol">n2</span>++)
		{
			if (<span class="amxx-symbol">n2</span> == <span class="amxx-number">1</span>) { <span class="amxx-symbol">n2</span> = <span class="amxx-number">2</span>; <span class="amxx-symbol">number</span> = <span class="amxx-number">2</span>; }
			<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d, n2 = %d"</span>, <span class="amxx-symbol">number</span>, <span class="amxx-symbol">n2</span>);
		}
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]number = %d"</span>, <span class="amxx-symbol">number</span>);
	}
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]循环-结束!"</span>);
}</code></p>

<p>打印结果:</p>

<p><code><span class="amxx-note">[AMXX]number = 0, n2 = 0
[AMXX]number = 2, n2 = 2
[AMXX]number = 2
[AMXX]循环-结束!</span></code></p>

<p>可以看到,在<span class="amxx-symbol">n2</span>满足等于1的条件后,将<span class="amxx-symbol">n2 number</span>赋值为2.结果是打印了<span class="amxx-string">"[AMXX]number = 2, n2 = 2"</span>.</p>

<p>接下来会前往执行<span class="amxx-symbol">n2</span><code>++</code>,结果是<span class="amxx-symbol">n2</span>自增为3.接下来会前往判断<span class="amxx-symbol">n2</span> <code><</code> 3,由于3 <code><</code> 3等于0,无法再次进入循环体.</p>

<p>因此深层循环停止,接下来打印了<span class="amxx-string">"[AMXX]number = 2"</span>.</p>

<p>再前往<span class="amxx-symbol">number</span><code>++</code>,结果是<span class="amxx-symbol">number</span>自增为3,再前往判断<span class="amxx-symbol">number</span> <code><</code> 3,由于3 <code><</code> 3等于0,无法再次进入循环体.</p>

<p>因此外层循环停止,最终打印<span class="amxx-string">"[AMXX]循环-结束!"</span>.</p>

<p>这种写法需要对<code>for</code>循环有足够深的理解,需要知道代码具体的执行流程.</p>

<p>由于该写法的应用场景很罕见,不用太过在意.不过了解一下也是好的.能提高开发者的逻辑思维能力.</p>

<p><h1 id="click4">4:实例-循环实际应用</h1></p>

<p><h2 id="click4_1">4.1:计算数量</h2></p>

<p>以下代码,用<code>for</code>循环计数,实现了两个功能:</p>

<p>玩家在未死亡情况下,按下[E]键,在聊天框打印游戏中活人数量.</p>

<p>玩家在未死亡情况下,按下[CTRL]键,在聊天框打印游戏中活着的匪徒数量.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
<span class="amxx-directive">#include</span> <span class="amxx-string">fakemeta</span>

<span class="amxx-comment">// 声明全局变量gMaxClients,用于储存:服务器最大玩家数</span>
new <span class="amxx-symbol">gMaxClients</span>;

public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	<span class="amxx-comment">// 为"玩家预思考事件"添加后置挂钩,挂钩的回调函数名为:Player_PreThink_PostHook,
	// 每当"玩家预思考事件"被触发,就在触发之后调用一次回调函数</span>
	<span class="amxx-function">register_forward</span>(<span class="amxx-symbol">FM_PlayerPreThink</span>, <span class="amxx-string">"Player_PreThink_PostHook"</span>, <span class="amxx-number">1</span>);
	
	<span class="amxx-comment">// 获取服务器最大玩家数(选择地图时可以设置这个数量),储存至gMaxClients全局变量</span>
	<span class="amxx-symbol">gMaxClients</span> = <span class="amxx-function">global_get</span>(<span class="amxx-symbol">glb_maxClients</span>);
}

<span class="amxx-comment">// 声明公共函数:Player_PreThink_PostHook,充当"玩家预思考事件后置挂钩"的回调函数</span>
public <span class="amxx-function">Player_PreThink_PostHook</span>(<span class="amxx-symbol">thinkerEntId</span>)
{
	<span class="amxx-comment">// 若思考者不是活人,返回</span>
	if (!<span class="amxx-function">is_user_alive</span>(<span class="amxx-symbol">thinkerEntId</span>)) return;
	
	<span class="amxx-comment">// 获取上次,这次思考时按住的按键,分别存入oldButtons和buttons变量</span>
	new <span class="amxx-symbol">oldButtons</span> = <span class="amxx-function">pev</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">pev_oldbuttons</span>);
	new <span class="amxx-symbol">buttons</span> = <span class="amxx-function">pev</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">pev_button</span>);
	
	<span class="amxx-comment">// 如果思考者按下"使用键"(一般是[E]键)</span>
	if (!(<span class="amxx-symbol">oldButtons</span> & <span class="amxx-symbol">IN_USE</span>) && <span class="amxx-symbol">buttons</span> & <span class="amxx-symbol">IN_USE</span>)
	{
		<span class="amxx-comment">// 声明counter变量,用于计数</span>
		new <span class="amxx-symbol">counter</span>;
		<span class="amxx-comment">// 声明playerEntId变量,用于表示玩家实体索引,在循环体内访问gMaxClients至1号玩家实体索引</span>
		for (new <span class="amxx-symbol">playerEntId</span> = <span class="amxx-symbol">gMaxClients</span>; <span class="amxx-symbol">playerEntId</span>; <span class="amxx-symbol">playerEntId</span>--)
		{
			<span class="amxx-comment">// 若该索引指向一个活的玩家,而不是虚无或死者.那么counter计数器自增1</span>
			if (<span class="amxx-function">is_user_alive</span>(<span class="amxx-symbol">playerEntId</span>)) <span class="amxx-symbol">counter</span>++;
		}
		<span class="amxx-comment">// 打印计数结果</span>
		<span class="amxx-function">client_print</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">print_chat</span>, <span class="amxx-string">"[AMXX]目前有%d个活着的玩家."</span>, <span class="amxx-symbol">counter</span>);
	}
	<span class="amxx-comment">// 如果思考者按下"下蹲键"(一般是[CTRL]键)</span>
	if (!(<span class="amxx-symbol">oldButtons</span> & <span class="amxx-symbol">IN_DUCK</span>) && <span class="amxx-symbol">buttons</span> & <span class="amxx-symbol">IN_DUCK</span>)
	{
		<span class="amxx-comment">// 声明counter变量,用于计数</span>
		new <span class="amxx-symbol">counter</span>;
		<span class="amxx-comment">// 声明playerEntId变量,用于表示玩家实体索引,在循环体内访问gMaxClients至1号玩家实体索引</span>
		for (new <span class="amxx-symbol">playerEntId</span> = <span class="amxx-symbol">gMaxClients</span>; <span class="amxx-symbol">playerEntId</span>; <span class="amxx-symbol">playerEntId</span>--)
		{
			<span class="amxx-comment">// 若该索引指向一个活的1号队伍玩家,而不是虚无或死者或其它队伍.那么counter计数器自增1</span>
			if (<span class="amxx-function">is_user_alive</span>(<span class="amxx-symbol">playerEntId</span>) && <span class="amxx-function">get_user_team</span>(<span class="amxx-symbol">playerEntId</span>) == <span class="amxx-number">1</span>) <span class="amxx-symbol">counter</span>++;
		}
		<span class="amxx-comment">// 打印计数结果</span>
		<span class="amxx-function">client_print</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">print_chat</span>, <span class="amxx-string">"[AMXX]1号队伍(匪徒)目前有%d个活着的玩家."</span>, <span class="amxx-symbol">counter</span>);
	}
}</code></p>

<p><h2 id="click4_2">4.2:收集满足条件的对象</h2></p>

<p>以下代码,用<code>for</code>循环计数,并收集满足条件的对象.实现了以下功能:</p>

<p>玩家在未死亡情况下,按下[E]键,选中所有活人的实体索引,存入数组.</p>

<p>从数组中随机挑选一个元素,杀死该元素所指的玩家.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
<span class="amxx-directive">#include</span> <span class="amxx-string">fakemeta</span>

<span class="amxx-comment">// 声明全局变量gMaxClients,用于储存:服务器最大玩家数</span>
new <span class="amxx-symbol">gMaxClients</span>;

public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	<span class="amxx-comment">// 为"玩家预思考事件"添加后置挂钩,挂钩的回调函数名为:Player_PreThink_PostHook,
	// 每当"玩家预思考事件"被触发,就在触发之后调用一次回调函数</span>
	<span class="amxx-function">register_forward</span>(<span class="amxx-symbol">FM_PlayerPreThink</span>, <span class="amxx-string">"Player_PreThink_PostHook"</span>, <span class="amxx-number">1</span>);
	
	<span class="amxx-comment">// 获取服务器最大玩家数(选择地图时可以设置这个数量),储存至gMaxClients全局变量</span>
	<span class="amxx-symbol">gMaxClients</span> = <span class="amxx-function">global_get</span>(<span class="amxx-symbol">glb_maxClients</span>);
}

<span class="amxx-comment">// 声明公共函数:Player_PreThink_PostHook,充当"玩家预思考事件后置挂钩"的回调函数</span>
public <span class="amxx-function">Player_PreThink_PostHook</span>(<span class="amxx-symbol">thinkerEntId</span>)
{
	<span class="amxx-comment">// 若思考者不是活人,返回</span>
	if (!<span class="amxx-function">is_user_alive</span>(<span class="amxx-symbol">thinkerEntId</span>)) return;
	
	<span class="amxx-comment">// 获取上次,这次思考时按住的按键,分别存入oldButtons和buttons变量</span>
	new <span class="amxx-symbol">oldButtons</span> = <span class="amxx-function">pev</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">pev_oldbuttons</span>);
	new <span class="amxx-symbol">buttons</span> = <span class="amxx-function">pev</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">pev_button</span>);
	
	<span class="amxx-comment">// 如果思考者按下"使用键"(一般是[E]键)</span>
	if (!(<span class="amxx-symbol">oldButtons</span> & <span class="amxx-symbol">IN_USE</span>) && <span class="amxx-symbol">buttons</span> & <span class="amxx-symbol">IN_USE</span>)
	{
		<span class="amxx-comment">// 声明counter变量,用于计数</span>
		new <span class="amxx-symbol">counter</span>;
		<span class="amxx-comment">// 声明容量为32的数组变量players,用于存放玩家的实体索引(CS1.6服务器最多只允许32名玩家进入)</span>
		new <span class="amxx-symbol">players</span>[<span class="amxx-number">32</span>];
		<span class="amxx-comment">// 声明playerEntId变量,用于表示玩家实体索引,在循环体内访问gMaxClients至1号玩家实体索引</span>
		for (new <span class="amxx-symbol">playerEntId</span> = <span class="amxx-symbol">gMaxClients</span>; <span class="amxx-symbol">playerEntId</span>; <span class="amxx-symbol">playerEntId</span>--)
		{
			<span class="amxx-comment">// 若该索引指向一个活的玩家,而不是虚无或死者.那么存入players[counter],然后counter自增1</span>
			if (<span class="amxx-function">is_user_alive</span>(<span class="amxx-symbol">playerEntId</span>)) <span class="amxx-symbol">players</span>[<span class="amxx-symbol">counter</span>++] = <span class="amxx-symbol">playerEntId</span>;++;
		}
		<span class="amxx-comment">// 打印计数结果</span>
		<span class="amxx-function">client_print</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">print_chat</span>, <span class="amxx-string">"[AMXX]目前有%d个活着的玩家.他们的实体索引已被存入活人数组."</span>, <span class="amxx-symbol">counter</span>);
		
		<span class="amxx-comment">// 若数量不为0</span>
		if (<span class="amxx-symbol">counter</span>)
		{
			<span class="amxx-comment">// 声明elementId变量,在0至counter-1范围中随机取值,存入elementId变量</span>
			new <span class="amxx-symbol">elementId</span> = <span class="amxx-function">random</span>(<span class="amxx-symbol">counter</span>);
			<span class="amxx-function">client_print</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">print_chat</span>, <span class="amxx-string">"[AMXX]在活人数组中,随机选中了[%d]号元素.元素存放的是玩家实体索引[%d]."</span>, <span class="amxx-symbol">elementId</span>, <span class="amxx-symbol">players</span>[<span class="amxx-symbol">elementId</span>]);
			
			<span class="amxx-comment">// 访问players的elementId号元素,杀死该元素所指的玩家</span>
			<span class="amxx-function">user_kill</span>(<span class="amxx-symbol">players</span>[<span class="amxx-symbol">elementId</span>]);
			<span class="amxx-function">client_print</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">print_chat</span>, <span class="amxx-string">"[AMXX]实体索引为[%d]的玩家 -- %n -- 杀死!."</span>, <span class="amxx-symbol">players</span>[<span class="amxx-symbol">elementId</span>], <span class="amxx-symbol">players</span>[<span class="amxx-symbol">elementId</span>]);
		}
		<span class="amxx-comment">// 打印计数结果</span>
		<span class="amxx-function">client_print</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">print_chat</span>, <span class="amxx-string">"[AMXX]目前有%d个活着的玩家."</span>, <span class="amxx-symbol">counter</span>);
	}
}</code></p>

<p><h2 id="click4_3">4.2:找最低值(寻找最近的活者)</h2></p>

<p>以下代码可寻找数组中的最小值.通常可用于寻找拥有最低分数的玩家,距离最近的玩家等等.</p>

<p><code>#include <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	<span class="amxx-comment">// 假设总共有10个数值</span>
	new <span class="amxx-symbol">values</span>[<span class="amxx-number">10</span>] = { <span class="amxx-number">430</span>, <span class="amxx-number">320</span>, <span class="amxx-number">210</span>, <span class="amxx-number">100</span>, <span class="amxx-number">50</span>, <span class="amxx-number">60</span>, <span class="amxx-number">30</span>, <span class="amxx-number">40</span>, <span class="amxx-number">10</span>, <span class="amxx-number">20</span> };
	
	<span class="amxx-comment">// 声明充当索引记录器的变量,用于记录存有最小值的元素的索引,并初始化为-1.</span>
	<span class="amxx-comment">// 由于有效索引是0至9,因此-1是一个无效索引.如果for查询完毕后索引记录器依然是-1,</span>
	<span class="amxx-comment">// 说明未能找到最小值(values容量为0或所有元素都被continue跳过)</span>
	new <span class="amxx-symbol">selectedElementId</span> = -<span class="amxx-number">1</span>;
	<span class="amxx-comment">// 声明两个充当数值记录器的变量,分别用于记录此次循环的数值,与目前已知的最小值</span>
	new <span class="amxx-symbol">value</span>, <span class="amxx-symbol">minValue</span>;
	
	<span class="amxx-comment">// 根据表达式1和2的设定,循环体内的elementId将会是9至0号</span>
	for (new <span class="amxx-symbol">elementId</span> = sizeof(<span class="amxx-symbol">values</span>); <span class="amxx-symbol">elementId</span>--;)
	{
		<span class="amxx-comment">// 访问values数组的elementId号元素,将其数值存入value</span>
		<span class="amxx-symbol">value</span> = <span class="amxx-symbol">values</span>[<span class="amxx-symbol">elementId</span>];
		<span class="amxx-comment">// 若当前数值小于已知最小值,或此前尚未记录最小值(一旦记录,selectedElemtId就不再小于0)</span>
		if (<span class="amxx-symbol">value</span> < <span class="amxx-symbol">minValue</span> || <span class="amxx-symbol">selectedElementId</span> < <span class="amxx-number">0</span>)
		{
			<span class="amxx-comment">// 将value作为已知最小值,存入minValue,用于下一轮作比较</span>
			<span class="amxx-symbol">minValue</span> = <span class="amxx-symbol">value</span>;
			<span class="amxx-comment">// 记录已知最小值的元素索引</span>
			<span class="amxx-symbol">selectedElementId</span> = <span class="amxx-symbol">elementId</span>;
			<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]已知最小值 : values[%d] = %d"</span>, <span class="amxx-symbol">elementId</span>, <span class="amxx-symbol">value</span>);
		}
		else	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]未能满足记录条件 : values[%d] = %d"</span>, <span class="amxx-symbol">elementId</span>, <span class="amxx-symbol">value</span>);
	}
	
	if (<span class="amxx-symbol">selectedElementId</span> < <span class="amxx-number">0</span>)
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]选中元素索引为-1,说明数组容量为0,或循环中跳过了数组的所有元素."</span>);
	else
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]选中元素索引为%d,values[%d]的值%d,是values数组中最小的一个."</span>, <span class="amxx-symbol">selectedElementId</span>, <span class="amxx-symbol">selectedElementId</span>, <span class="amxx-symbol">minValue</span>);
}</code></p>

<p>打印结果为:</p>

<p><code><span class="amxx-note">[AMXX]已知最小值 : values[9] = 20
[AMXX]已知最小值 : values[8] = 10
[AMXX]未能满足记录条件 : values[7] = 40
[AMXX]未能满足记录条件 : values[6] = 30
[AMXX]未能满足记录条件 : values[5] = 60
[AMXX]未能满足记录条件 : values[4] = 50
[AMXX]未能满足记录条件 : values[3] = 100
[AMXX]未能满足记录条件 : values[2] = 210
[AMXX]未能满足记录条件 : values[1] = 320
[AMXX]未能满足记录条件 : values[0] = 430
[AMXX]选中元素索引为8,values[8]的值10,是values数组中最小的一个.</span></code></p>

<p>可见7至0号元素的值统统不满足"小于已知最小值"或"尚未记录最小值"两个条件.因此最小值的索引记录器,数值记录器再也没有更新.</p>

<p>循环结束后,便可确认<span class="amxx-symbol">values</span>[8]存有最小值.</p>

<p>用以下代码,使玩家在按下[E]键时,查找除自己以外的最近活者.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
<span class="amxx-directive">#include</span> <span class="amxx-string">fakemeta</span>

<span class="amxx-comment">// 声明全局变量gMaxClients,用于储存:服务器最大玩家数</span>
new <span class="amxx-symbol">gMaxClients</span>;
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	<span class="amxx-comment">// 为"玩家预思考事件"添加后置挂钩,挂钩的回调函数名为:Player_PreThink_PostHook,</span>
	<span class="amxx-comment">// 每当"玩家预思考事件"被触发,就在触发之后调用一次回调函数</span>
	<span class="amxx-function">register_forward</span>(<span class="amxx-symbol">FM_PlayerPreThink</span>, <span class="amxx-string">"Player_PreThink_PostHook"</span>, <span class="amxx-number">1</span>);
	
	<span class="amxx-comment">// 获取服务器最大玩家数(选择地图时可以设置这个数量),储存至gMaxClients全局变量</span>
	<span class="amxx-symbol">gMaxClients</span> = <span class="amxx-function">global_get</span>(<span class="amxx-symbol">glb_maxClients</span>);
}

<span class="amxx-comment">// 声明公共函数:Player_PreThink_PostHook,充当"玩家预思考事件后置挂钩"的回调函数</span>
public <span class="amxx-function">Player_PreThink_PostHook</span>(<span class="amxx-symbol">thinkerEntId</span>)
{
	<span class="amxx-comment">// 若思考者是个死人,返回</span>
	if (!<span class="amxx-function">is_user_alive</span>(<span class="amxx-symbol">thinkerEntId</span>)) return;
	
	<span class="amxx-comment">// 获取上次,这次思考时按住的按键,分别存入oldButtons和buttons变量</span>
	new <span class="amxx-symbol">oldButtons</span> = <span class="amxx-function">pev</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">pev_oldbuttons</span>);
	new <span class="amxx-symbol">buttons</span> = <span class="amxx-function">pev</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">pev_button</span>);
	
	<span class="amxx-comment">// 如果思考者按下"使用键"(一般是[E]键)</span>
	if (!(<span class="amxx-symbol">oldButtons</span> & <span class="amxx-symbol">IN_USE</span>) && <span class="amxx-symbol">buttons</span> & <span class="amxx-symbol">IN_USE</span>)
	{
		<span class="amxx-comment">// 声明origin与dest数组,用于储存思考者与其他玩家的坐标</span>
		new <span class="amxx-tag">Float:</span><span class="amxx-symbol">origin</span>[<span class="amxx-number">3</span>], <span class="amxx-tag">Float:</span><span class="amxx-symbol">dest</span>[<span class="amxx-number">3</span>];
		
		<span class="amxx-comment">// 对thinkerEntId所指玩家访问pev_origin常量所指的属性(坐标),将坐标值存入origin</span>
		<span class="amxx-function">pev</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">pev_origin</span>, <span class="amxx-symbol">origin</span>);
		
		<span class="amxx-comment">// 实体索引记录器,当前距离记录器,已知最小距离记录器</span>
		new <span class="amxx-symbol">selectedEntId</span>, <span class="amxx-tag">Float:</span><span class="amxx-symbol">dist</span>, <span class="amxx-tag">Float:</span><span class="amxx-symbol">minDist</span>;
		
		<span class="amxx-comment">// 根据表达式1/2/3的设定,循环体内playerEntId将会是gMaxClients至1</span>
		for (new <span class="amxx-symbol">playerEntId</span> = <span class="amxx-symbol">gMaxClients</span>; <span class="amxx-symbol">playerEntId</span>; <span class="amxx-symbol">playerEntId</span>--)
		{
			<span class="amxx-comment">// 跳过思考者自己</span>
			if (<span class="amxx-symbol">playerEntId</span> == <span class="amxx-symbol">thinkerEntId</span>) continue;
			<span class="amxx-comment">// 跳过非活者</span>
			if (!<span class="amxx-function">is_user_alive</span>(<span class="amxx-symbol">playerEntId</span>)) continue;
			
			<span class="amxx-comment">// 对playerEntId所指玩家访问pev_origin常量所指的属性(坐标),将坐标值存入dest</span>
			<span class="amxx-function">pev</span>(<span class="amxx-symbol">playerEntId</span>, <span class="amxx-symbol">pev_origin</span>, <span class="amxx-symbol">dest</span>);
			
			<span class="amxx-comment">// 计算origin与dest坐标的直线距离,存入dist</span>
			<span class="amxx-symbol">dist</span> = <span class="amxx-function">get_distance_f</span>(<span class="amxx-symbol">origin</span>, <span class="amxx-symbol">dest</span>);
			
			<span class="amxx-comment">// 若当前距离小于已知最小距离,或尚未记录最小距离和最近玩家实体索引</span>
			if (<span class="amxx-symbol">dist</span> < <span class="amxx-symbol">minDist</span> || !<span class="amxx-symbol">selectedEntId</span>)
			{
				<span class="amxx-comment">// 记录最小距离</span>
				<span class="amxx-symbol">minDist</span> = <span class="amxx-symbol">dist</span>;
				<span class="amxx-comment">// 记录最近玩家的实体索引</span>
				<span class="amxx-symbol">selectedEntId</span> = <span class="amxx-symbol">playerEntId</span>;
			}
		}
		
		<span class="amxx-comment">// 若selectedEntId非0(已记录最近玩家的实体索引)</span>
		if (<span class="amxx-symbol">selectedEntId</span>)
		{
			<span class="amxx-function">client_print</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">print_chat</span>, <span class="amxx-string">"[AMXX]与你最近的活者是:%n,距离:%.2f"</span>, <span class="amxx-symbol">selectedEntId</span>, <span class="amxx-symbol">minDist</span>);
			<span class="amxx-comment">// 杀死selectedEntId所指玩家</span>
			<span class="amxx-function">user_kill</span>(<span class="amxx-symbol">selectedEntId</span>);
		}
		<span class="amxx-comment">// 若selectedEntId为0(可能游戏中除了思考者以外已经没有其他活者)</span>
		else
		{
			<span class="amxx-function">client_print</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">print_chat</span>, <span class="amxx-string">"[AMXX]游戏中不存在除你以外的活者."</span>);
		}
	}
}</code></p>

<p><h2 id="click4_2">4.2:找最高值(寻找最远的活者)</h2></p>

<p>以下代码可寻找数组中的最大值.通常可用于寻找拥有最高分数的玩家,距离最远的玩家等等.</p>

<p><code>#include <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	<span class="amxx-comment">// 假设总共有10个数值</span>
	new <span class="amxx-symbol">values</span>[<span class="amxx-number">10</span>] = { <span class="amxx-number">430</span>, <span class="amxx-number">320</span>, <span class="amxx-number">210</span>, <span class="amxx-number">100</span>, <span class="amxx-number">50</span>, <span class="amxx-number">60</span>, <span class="amxx-number">30</span>, <span class="amxx-number">40</span>, <span class="amxx-number">10</span>, <span class="amxx-number">20</span> };
	
	<span class="amxx-comment">// 声明充当索引记录器的变量,用于记录存有最小值的元素的索引,并初始化为-1.</span>
	<span class="amxx-comment">// 由于有效索引是0至9,因此-1是一个无效索引.如果for查询完毕后索引记录器依然是-1,</span>
	<span class="amxx-comment">// 说明未能找到最小值(values容量为0或所有元素都被continue跳过)</span>
	new <span class="amxx-symbol">selectedElementId</span> = -<span class="amxx-number">1</span>;
	<span class="amxx-comment">// 声明两个充当数值记录器的变量,分别用于记录此次循环的数值,与目前已知的最大值</span>
	new <span class="amxx-symbol">value</span>, <span class="amxx-symbol">maxValue</span>;
	
	<span class="amxx-comment">// 根据表达式1和2的设定,循环体内的elementId将会是9至0号</span>
	for (new <span class="amxx-symbol">elementId</span> = sizeof(<span class="amxx-symbol">values</span>); <span class="amxx-symbol">elementId</span>--;)
	{
		<span class="amxx-comment">// 访问values数组的elementId号元素,将其数值存入value</span>
		<span class="amxx-symbol">value</span> = <span class="amxx-symbol">values</span>[<span class="amxx-symbol">elementId</span>];
		<span class="amxx-comment">// 若已知最大值小于当前数值,或此前尚未记录最大值(一旦记录,selectedElemtId就不再小于0)</span>
		if (<span class="amxx-symbol">maxValue</span> < <span class="amxx-symbol">value</span> || <span class="amxx-symbol">selectedElementId</span> < <span class="amxx-number">0</span>)
		{
			<span class="amxx-comment">// 将value作为已知最大值,存入maxValue,用于下一轮作比较</span>
			<span class="amxx-symbol">maxValue</span> = <span class="amxx-symbol">value</span>;
			<span class="amxx-comment">// 记录已知最大值的元素索引</span>
			<span class="amxx-symbol">selectedElementId</span> = <span class="amxx-symbol">elementId</span>;
			<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]已知最大值 : values[%d] = %d"</span>, <span class="amxx-symbol">elementId</span>, <span class="amxx-symbol">value</span>);
		}
		else	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]未能满足记录条件 : values[%d] = %d"</span>, <span class="amxx-symbol">elementId</span>, <span class="amxx-symbol">value</span>);
	}
	
	if (<span class="amxx-symbol">selectedElementId</span> < <span class="amxx-number">0</span>)
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]选中元素索引为-1,说明数组容量为0,或循环中跳过了数组的所有元素."</span>);
	else
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]选中元素索引为%d,values[%d]的值%d,是values数组中最大的一个."</span>, <span class="amxx-symbol">selectedElementId</span>, <span class="amxx-symbol">selectedElementId</span>, <span class="amxx-symbol">maxValue</span>);
}</code></p>

<p>打印结果为:</p>

<p><code><span class="amxx-note">
[AMXX]已知最大值 : values[9] = 20
[AMXX]未能满足记录条件 : values[8] = 10
[AMXX]已知最大值 : values[7] = 40
[AMXX]未能满足记录条件 : values[6] = 30
[AMXX]已知最大值 : values[5] = 60
[AMXX]未能满足记录条件 : values[4] = 50
[AMXX]已知最大值 : values[3] = 100
[AMXX]已知最大值 : values[2] = 210
[AMXX]已知最大值 : values[1] = 320
[AMXX]已知最大值 : values[0] = 430
[AMXX]选中元素索引为0,values[0]的值430,是values数组中最大的一个.</span></code></p>

<p>可见8,6,4号元素的值不满足"大于已知最大值"或"尚未记录最大值"两个条件.因此最大值的索引记录器,数值记录器没有更新.</p>

<p>接下来的3,2,1,0都满足的更新记录器的条件.循环结束后,便可确认<span class="amxx-symbol">values</span>[0]存有最大值.</p>

<p>用以下代码,使玩家在按下[E]键时,查找除自己以外的最远活者.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
<span class="amxx-directive">#include</span> <span class="amxx-string">fakemeta</span>

<span class="amxx-comment">// 声明全局变量gMaxClients,用于储存:服务器最大玩家数</span>
new <span class="amxx-symbol">gMaxClients</span>;
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	<span class="amxx-comment">// 为"玩家预思考事件"添加后置挂钩,挂钩的回调函数名为:Player_PreThink_PostHook,</span>
	<span class="amxx-comment">// 每当"玩家预思考事件"被触发,就在触发之后调用一次回调函数</span>
	<span class="amxx-function">register_forward</span>(<span class="amxx-symbol">FM_PlayerPreThink</span>, <span class="amxx-string">"Player_PreThink_PostHook"</span>, <span class="amxx-number">1</span>);
	
	<span class="amxx-comment">// 获取服务器最大玩家数(选择地图时可以设置这个数量),储存至gMaxClients全局变量</span>
	<span class="amxx-symbol">gMaxClients</span> = <span class="amxx-function">global_get</span>(<span class="amxx-symbol">glb_maxClients</span>);
}

<span class="amxx-comment">// 声明公共函数:Player_PreThink_PostHook,充当"玩家预思考事件后置挂钩"的回调函数</span>
public <span class="amxx-function">Player_PreThink_PostHook</span>(<span class="amxx-symbol">thinkerEntId</span>)
{
	<span class="amxx-comment">// 若思考者是个死人,返回</span>
	if (!<span class="amxx-function">is_user_alive</span>(<span class="amxx-symbol">thinkerEntId</span>)) return;
	
	<span class="amxx-comment">// 获取上次,这次思考时按住的按键,分别存入oldButtons和buttons变量</span>
	new <span class="amxx-symbol">oldButtons</span> = <span class="amxx-function">pev</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">pev_oldbuttons</span>);
	new <span class="amxx-symbol">buttons</span> = <span class="amxx-function">pev</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">pev_button</span>);
	
	<span class="amxx-comment">// 如果思考者按下"使用键"(一般是[E]键)</span>
	if (!(<span class="amxx-symbol">oldButtons</span> & <span class="amxx-symbol">IN_USE</span>) && <span class="amxx-symbol">buttons</span> & <span class="amxx-symbol">IN_USE</span>)
	{
		<span class="amxx-comment">// 声明origin与dest数组,用于储存思考者与其他玩家的坐标</span>
		new <span class="amxx-tag">Float:</span><span class="amxx-symbol">origin</span>[<span class="amxx-number">3</span>], <span class="amxx-tag">Float:</span><span class="amxx-symbol">dest</span>[<span class="amxx-number">3</span>];
		
		<span class="amxx-comment">// 对thinkerEntId所指玩家访问pev_origin常量所指的属性(坐标),将坐标值存入origin</span>
		<span class="amxx-function">pev</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">pev_origin</span>, <span class="amxx-symbol">origin</span>);
		
		<span class="amxx-comment">// 实体索引记录器,当前距离记录器,已知最小距离记录器</span>
		new <span class="amxx-symbol">selectedEntId</span>, <span class="amxx-tag">Float:</span><span class="amxx-symbol">dist</span>, <span class="amxx-tag">Float:</span><span class="amxx-symbol">maxDist</span>;
		
		<span class="amxx-comment">// 根据表达式1/2/3的设定,循环体内playerEntId将会是gMaxClients至1</span>
		for (new <span class="amxx-symbol">playerEntId</span> = <span class="amxx-symbol">gMaxClients</span>; <span class="amxx-symbol">playerEntId</span>; <span class="amxx-symbol">playerEntId</span>--)
		{
			<span class="amxx-comment">// 跳过思考者自己</span>
			if (<span class="amxx-symbol">playerEntId</span> == <span class="amxx-symbol">thinkerEntId</span>) continue;
			<span class="amxx-comment">// 跳过非活者</span>
			if (!<span class="amxx-function">is_user_alive</span>(<span class="amxx-symbol">playerEntId</span>)) continue;
			
			<span class="amxx-comment">// 对playerEntId所指玩家访问pev_origin常量所指的属性(坐标),将坐标值存入dest</span>
			<span class="amxx-function">pev</span>(<span class="amxx-symbol">playerEntId</span>, <span class="amxx-symbol">pev_origin</span>, <span class="amxx-symbol">dest</span>);
			
			<span class="amxx-comment">// 计算origin与dest坐标的直线距离,存入dist</span>
			<span class="amxx-symbol">dist</span> = <span class="amxx-function">get_distance_f</span>(<span class="amxx-symbol">origin</span>, <span class="amxx-symbol">dest</span>);
			
			<span class="amxx-comment">// 若已知最大距离小于当前距离,或尚未记录最大距离和最远玩家实体索引</span>
			if (<span class="amxx-symbol">maxDist</span> < <span class="amxx-symbol">dist</span> || !<span class="amxx-symbol">selectedEntId</span>)
			{
				<span class="amxx-comment">// 记录最大距离</span>
				<span class="amxx-symbol">maxDist</span> = <span class="amxx-symbol">dist</span>;
				<span class="amxx-comment">// 记录最近玩家的实体索引</span>
				<span class="amxx-symbol">selectedEntId</span> = <span class="amxx-symbol">playerEntId</span>;
			}
		}
		
		<span class="amxx-comment">// 若selectedEntId非0(已记录最远玩家的实体索引)</span>
		if (<span class="amxx-symbol">selectedEntId</span>)
		{
			<span class="amxx-function">client_print</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">print_chat</span>, <span class="amxx-string">"[AMXX]与你最远的活者是:%n,距离:%.2f"</span>, <span class="amxx-symbol">selectedEntId</span>, <span class="amxx-symbol">maxDist</span>);
			<span class="amxx-comment">// 杀死selectedEntId所指玩家</span>
			<span class="amxx-function">user_kill</span>(<span class="amxx-symbol">selectedEntId</span>);
		}
		<span class="amxx-comment">// 若selectedEntId为0(可能游戏中除了思考者以外已经没有其他活者)</span>
		else
		{
			<span class="amxx-function">client_print</span>(<span class="amxx-symbol">thinkerEntId</span>, <span class="amxx-symbol">print_chat</span>, <span class="amxx-string">"[AMXX]游戏中不存在除你以外的活者."</span>);
		}
	}
}</code></p>

<p><h1 id="click5">5:将for语句的代码执行流程打印到控制台</h1></p>

<p>用以下代码,展示for语句的代码执行流程.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>

new <span class="amxx-symbol">gNumber</span>;
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">register_plugin</span>(<span class="amxx-string">"循环测试"</span>, <span class="amxx-string">"1.0.0"</span>, <span class="amxx-string">"偶萤蛉(Oinling)"</span>);
	
	for (<span class="amxx-function">E1</span>(); <span class="amxx-function">E2</span>(); <span class="amxx-function">E3</span>())
	{
		<span class="amxx-function">BodyCode</span>();
	}
	<span class="amxx-function">ForEnd</span>();
}

static <span class="amxx-function">E1</span>()
{
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"表达式1 ... : 执行gNumber = 0"</span>);
	<span class="amxx-symbol">gNumber</span> = <span class="amxx-number">0</span>;
}

static <span class="amxx-tag">bool:</span><span class="amxx-function">E2</span>()
{
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"表达式2 ... 此时gNumber为%d : 判断gNumber < 10"</span>, <span class="amxx-symbol">gNumber</span>);
	return <span class="amxx-symbol">gNumber</span> < <span class="amxx-number">10</span>;
}

static <span class="amxx-function">E3</span>()
{
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"表达式3 ... 此时gNumber为%d : 执行gNumber++"</span>, <span class="amxx-symbol">gNumber</span>);
	<span class="amxx-symbol">gNumber</span>++;
}

static <span class="amxx-function">BodyCode</span>()
{
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"循环体代码 ... 此时gNumber为%d"</span>, <span class="amxx-symbol">gNumber</span>);
}

static <span class="amxx-function">ForEnd</span>()
{
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"循环体结束... 此时gNumber为%d"</span>, <span class="amxx-symbol">gNumber</span>);
}</code></p>

<p>打印结果:</p>

<p><code><span class="amxx-note">表达式1 ... : 执行gNumber = 0
表达式2 ... 此时gNumber为0 : 判断gNumber < 10
循环体代码 ... 此时gNumber为0
表达式3 ... 此时gNumber为0 : 执行gNumber++
表达式2 ... 此时gNumber为1 : 判断gNumber < 10
循环体代码 ... 此时gNumber为1
表达式3 ... 此时gNumber为1 : 执行gNumber++
表达式2 ... 此时gNumber为2 : 判断gNumber < 10
循环体代码 ... 此时gNumber为2
表达式3 ... 此时gNumber为2 : 执行gNumber++
表达式2 ... 此时gNumber为3 : 判断gNumber < 10
循环体代码 ... 此时gNumber为3
表达式3 ... 此时gNumber为3 : 执行gNumber++
表达式2 ... 此时gNumber为4 : 判断gNumber < 10
循环体代码 ... 此时gNumber为4
表达式3 ... 此时gNumber为4 : 执行gNumber++
表达式2 ... 此时gNumber为5 : 判断gNumber < 10
循环体代码 ... 此时gNumber为5
表达式3 ... 此时gNumber为5 : 执行gNumber++
表达式2 ... 此时gNumber为6 : 判断gNumber < 10
循环体代码 ... 此时gNumber为6
表达式3 ... 此时gNumber为6 : 执行gNumber++
表达式2 ... 此时gNumber为7 : 判断gNumber < 10
循环体代码 ... 此时gNumber为7
表达式3 ... 此时gNumber为7 : 执行gNumber++
表达式2 ... 此时gNumber为8 : 判断gNumber < 10
循环体代码 ... 此时gNumber为8
表达式3 ... 此时gNumber为8 : 执行gNumber++
表达式2 ... 此时gNumber为9 : 判断gNumber < 10
循环体代码 ... 此时gNumber为9
表达式3 ... 此时gNumber为9 : 执行gNumber++
表达式2 ... 此时gNumber为10 : 判断gNumber < 10
循环体结束... 此时gNumber为10</span></code></p>

</body>
</html>
