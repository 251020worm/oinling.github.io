<!DOCTYPE html><html>
<head>
<meta charset="utf-8">
<title>cs1.6 amxx编程 enum精研教程 -- 作者:偶萤蛉(Oinling)</title>
<style>
	code {
		white-space: pre;
		color: rgb(0,0,255);
		background-color: #f1f1f1;
		font-family: Consolas, monospace;
		font-weight: bold;
	}
	.amxx-note {
		color: rgb(0,0,0);
		font-weight: normal;
	}
	.amxx-enumname {
		background: linear-gradient(to right, rgb(93,20,10), rgb(153,51,255));
		-webkit-background-clip: text;
		color: transparent;
	}
	.amxx-di {
		background: linear-gradient(to right, rgb(111,111,107), rgb(153,51,255));
		-webkit-background-clip: text;
		color: transparent;
		font-weight: normal;
	}
	.amxx-number {
		color: rgb(0,0,0);
		font-weight: normal;
	}
	.amxx-comment {
		color: rgb(63,159,63);
		font-weight: normal;
	}
	.amxx-string {
		color: rgb(193,61,41);
		font-weight: normal;
	}
	.amxx-directive {
		color: rgb(111,111,107);
		font-weight: normal;
	}
	.amxx-tag {
		color: rgb(93,20,10);
		font-weight: normal;
	}
	.amxx-symbol {
		color: rgb(153,51,255);
		font-weight: normal;
	}
	.amxx-function {
		color: rgb(113,31,195);
		font-weight: bold;
	}
</style>
</head>
<body>

<h1>cs1.6 amxx编程 enum精研教程 -- 作者:偶萤蛉(Oinling)</h1>

<h1>目录:</h1>

<p><a href="#click1">1:enum声明枚举常量的语法格式</a></p>

<p><a href="#click2">2:enum表达式详解</a></p>

<p><a href="#click2_1">2.1:enum</a></p>

<p><a href="#click2_2">2.2:枚举标签</a></p>

<p><a href="#click2_3">2.3:枚举名称</a></p>

<p><a href="#click2_4">2.4:增值法</a></p>

<p><a href="#click2_5">2.5:枚举体入口</a></p>

<p><a href="#click2_6">2.6:元素标签</a></p>

<p><a href="#click2_7">2.7:枚举成员名称</a></p>

<p><a href="#click2_8">2.8:元素尺寸</a></p>

<p><a href="#click2_9">2.9:初始化表达式</a></p>

<p><a href="#click2_10">2.10: , 符号</a></p>

<p><a href="#click2_11">2.11:枚举体出口</a></p>

<p><a href="#click2_12">2.12: ; 符号</a></p>

<p><a href="#click3">3:枚举实例</a></p>

<p><a href="#click3_1">3.1:枚举标签</a></p>

<p><a href="#click3_2">3.2:枚举名称</a></p>

<p><a href="#click3_3">3.3:增值法</a></p>

<p><a href="#click3_4">3.4:元素标签</a></p>

<p><a href="#click3_5">3.5:枚举成员名称</a></p>

<p><a href="#click3_6">3.6:元素尺寸</a></p>

<p><a href="#click3_7">3.7:初始化表达式</a></p>

<p><h1 id="click1">1:enum声明枚举常量的语法格式</h1></p>

<p><code>enum <span class="amxx-tag">枚举标签</span> <span class="amxx-symbol">枚举名称</span> 增值法
枚举体入口
	<span class="amxx-tag">元素标签</span> <span class="amxx-symbol">枚举成员名称1</span> <span class="amxx-number">元素尺寸</span> 初始化表达式,
	<span class="amxx-tag">元素标签</span> <span class="amxx-symbol">枚举成员名称2</span> <span class="amxx-number">元素尺寸</span> 初始化表达式,
	<span class="amxx-tag">元素标签</span> <span class="amxx-symbol">枚举成员名称3</span> <span class="amxx-number">元素尺寸</span> 初始化表达式,
枚举体出口;</code></p>

<p>参考:</p>

<p><code>enum <span class="amxx-tag">CsTeams:</span> <span class="amxx-symbol">Example</span> (+= <span class="amxx-number">2</span>)
{
	<span class="amxx-tag">any:</span>	<span class="amxx-symbol">Eg1</span> [<span class="amxx-number">3</span>] = <span class="amxx-number">0</span>,
	<span class="amxx-tag">bool:</span>	<span class="amxx-symbol">Eg2</span> [<span class="amxx-number">3</span>] = <span class="amxx-number">2</span>,
	<span class="amxx-tag">Float:</span>	<span class="amxx-symbol">Eg3</span> [<span class="amxx-number">3</span>] = <span class="amxx-number">2</span> + <span class="amxx-number">2</span>,
};</code></p>

<p><h1 id="click2">2:enum表达式详解</h1></p>

<p>除了<code>enum</code>和枚举体出入口,其它都是可省略的.也就是说,可以没有枚举成员.也可以设定多个枚举成员.</p>

<p>整个表达式中,所有运算表达式都仅支持编译时常量表达式.也就是说,填写运行时函数是不允许的.</p>

<p>包括浮点数的运算,同样是运行时执行,因此不可填写浮点数的运算表达式.</p>

<p>枚举通常用于提高代码的可读性,可维护性和安全性.</p>

<p>提高可读性:使用有意义的符号名称,代替字面量,可以让代码更易读和理解.</p>

<p>提高可维护性:如果需要修改常量值,只需要修改声明位置的初始化表达式,不需要在代码多处位置进行替换.</p>

<p>提高安全性:枚举可以限制只能从预定义值中选择,防止赋予无效的值.</p>

<p>枚举还有一些高级功能.</p>

<p>熟练使用枚举,可令AMXX插件拥有类似结构体,自定义类型,重载等一些面向对象的能力.</p>

<p>能帮助开发者提高代码的可维护性,方便地重复运用或扩展现有的代码.</p>

<p>能更直观地模拟实际世界中的实体及其关系,使编程思维贴近问题.<p>

<p><h2 id="click2_1">2.1:enum</h2></p>

<p><code>enum</code>可在函数体内使用,也可在函数体外使用.一般而言,<code>enum</code>用于声明全局常量.</p>

<p><h2 id="click2_2">2.2:枚举标签</h2></p>

<p>枚举标签用于设定常量拥有的标签,若省略,则以枚举名称作为标签.</p>

<p><h2 id="click2_3">2.3:枚举名称</h2></p>

<p>枚举名称是可自定义名称的常量标识符.参照标识符的命名规则.</p>

<p>若同时省略枚举标签与枚举名称,则以<span class="amxx-tag">_:</span>作为常量拥有的标签.</p>

<p><h2 id="click2_4">2.4:增值法</h2></p>

<p>增值法必须要有一对圆括号.其中可选则<code>+= *= <<=</code>三种运算符,表示每个成员与上一个成员的增值关系.</p>

<p>运算符的右值仅支持常量表达式.比如<code> (+= -<span class="amxx-number">5</span>) (<<= <span class="amxx-number">1</span>) (*= <span class="amxx-number">1</span> + <span class="amxx-number">1</span>) </code>等等.</p>

<p>省略增值法则默认使用<code>(+= <span class="amxx-number">1</span>)</code>增值法.表示每个成员等于上一成员的值+1.</p>

<p><h2 id="click2_5">2.5:枚举体入口</h2></p>

<p>枚举体入口,即代码块入口,用<code> { </code>符号表示.</p>

<p>枚举体内,只能声明枚举成员,不能运行函数,不能使用任意保留词.但允许访问其它无地址常量.</p>

<p><h2 id="click2_6">2.6:元素标签</h2></p>

<p>元素标签表示将该成员作为数组索引使用时,访问的元素拥有什么标签.若省略,则使用数组自身的标签.</p>

<p><h2 id="click2_7">2.7:枚举成员名称</h2></p>

<p>枚举成员是可自定义名称的常量标识符.参照标识符的命名规则.</p>

<p>枚举成员名称是可以与其它无地址常量标识符重名的.并且不同版本表现不同,在AMXX 1.9.0版本,开发者只能访问第一个声明的同名常量.</p>

<p>由于不会触发警告或报错,开发者应小心这一点,不要使用相同的命名.</p>

<p><h2 id="click2_8">2.8:元素尺寸</h2></p>

<p>元素尺寸用一对方括号包裹一个整数字面量表示.</p>

<p>枚举成员被用作数组索引时,元素尺寸用于告知编译器,以枚举成员的值为起点,将多少个连续元素视作整体.</p>

<p>这个整体,将被视作独立的数组(或字符串)元素,访问这个数组时,与其它数组一样.</p>

<p>若省略元素尺寸,则只能访问1个元素.</p>

<p><h2 id="click2_9">2.9:初始化表达式</h2></p>

<p>初始化表达式仅支持常量表达式,表示该枚举成员储存的字面量是什么.</p>

<p>若省略初始化表达式,则由增值法决定枚举成员储存的值.</p>

<p><h2 id="click2_10">2.10: , 符号</h2></p>

<p>若要连续声明多个枚举成员,用<code> , </code>符号隔开它们.</p>

<p>最后一个枚举成员可以省略结尾的<code> , </code>符号.但是保留也不会导致编译器警告或报错.</p>

<p><h2 id="click2_11">2.11:枚举体出口</h2></p>

<p>枚举体出口,即代码块出口.用<code> } </code>符号表示.</p>

<p>最终,由增值法决定枚举名称储存的值.若省略增值法,则默认枚举名称等于最后一个成员的值+1.</p>

<p>从枚举体出口开始,接下来代码中出现的枚举名称和枚举成员,都会在编译期间,被替换为它们储存的值.</p>

<p>因此,运行期间不需要通过查询地址访问数值,比起有地址的变量或常量,这种无地址常量有更高的效率.</p>

<p><h2 id="click2_12">2.12: ; 符号</h2></p>

<p>枚举体出口允许跟随一个<code> ; </code>符号,编译时会被编译器吃掉.而且检查分号模式下,不检查是否有分号.</p>

<p><h1 id="click3">3:枚举实例</h1></p>

<p><h2 id="click3_1">3.1:枚举标签</h2></p>

<p>在以下代码中,由于设定了枚举标签为<span class="amxx-tag">Float:</span>,因此<span class="amxx-symbol">Example</span>和<span class="amxx-symbol">Eg1</span>所储存的值带有<span class="amxx-tag">Float:</span>标签.</p>

<p><span class="amxx-function">float</span>函数要求参数1带有<span class="amxx-tag">_:</span>标签,因此会触发Tag mismatch警告(标签不匹配).</p>

<p><span class="amxx-function">floatround</span>函数要求参数1带有<span class="amxx-tag">Float:</span>标签,因此不会触发Tag mismatch警告(标签不匹配).</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	enum <span class="amxx-tag">Float:</span><span class="amxx-symbol">Example</span> { <span class="amxx-symbol">Eg1</span> }
	<span class="amxx-function">float</span>(<span class="amxx-symbol">Example</span>);
	<span class="amxx-function">float</span>(<span class="amxx-symbol">Eg1</span>);
	<span class="amxx-function">floatround</span>(<span class="amxx-symbol">Example</span>);
	<span class="amxx-function">floatround</span>(<span class="amxx-symbol">Eg1</span>);
}</code></p>

<p>填写了枚举标签后,编译器不会创建一个与枚举名称同名的标签.因此枚举名称失去标签的作用.</p>

<p>实际上,枚举时一般不填写枚举标签.</p>

<p><h2 id="click3_2">3.2:枚举名称</h2></p>

<p>枚举名称与宏定义相似,声明后便可以被引用.</p>

<p>编译时,源码中所有引用被删除,替换为其储存的字面量.</p>

<p>因此,枚举名称是一种无地址常量,它的值无法被更改.</p>

<p>在编译时就能确定无地址常量的值,运行时不需要加载标识符,因此效率更高.</p>

<p>以下代码用于展示它们的区别:</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-comment">// 用enum声明一个无地址常量:Example1</span>
	enum <span class="amxx-enumname">Example1</span> { }
	<span class="amxx-comment">// 对数组进行初始化,{}内可以填写Example1作为字面量.</span>
	new <span class="amxx-tag">Example1:</span><span class="amxx-symbol">array1</span>[<span class="amxx-number">1</span>] = { <span class="amxx-symbol">Example1</span> };
	
	<span class="amxx-comment">// 声明一个有地址常量:Example2</span>
	new const <span class="amxx-symbol">Example2</span> = <span class="amxx-number">6</span>;
	<span class="amxx-comment">// 编译器报错:初始化表达式必须是常量表达式.Example2不是一个真正的常量</span>
	new <span class="amxx-symbol">array2</span>[<span class="amxx-number">1</span>] = { <span class="amxx-symbol">Example2</span> };
	
	<span class="amxx-comment">// 此代码用于消除编译器警告:array1和array2未被使用</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">""</span>, <span class="amxx-symbol">array1</span>, <span class="amxx-symbol">array2</span>);
}</code></p>

<p>进入游戏载入地图后,在控制台观察以下代码的表现,可看出不同常量的效率差异.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">LoopTest</span>(<span class="amxx-string">"new"</span>, <span class="amxx-number">300</span>);
	<span class="amxx-function">LoopTest</span>(<span class="amxx-string">"static"</span>, <span class="amxx-number">300</span>);
	<span class="amxx-function">LoopTest</span>(<span class="amxx-string">"const"</span>, <span class="amxx-number">300</span>);
	<span class="amxx-function">LoopTest</span>(<span class="amxx-string">"enum"</span>, <span class="amxx-number">300</span>);
}
static <span class="amxx-function">LoopTest</span>(const <span class="amxx-symbol">specifier</span>[], <span class="amxx-symbol">numberOfCycles</span>)
{
	new <span class="amxx-symbol">counter</span>, <span class="amxx-symbol">counter2</span>, <span class="amxx-tag">Float:</span><span class="amxx-symbol">timer</span>, <span class="amxx-tag">Array:</span><span class="amxx-symbol">array</span> = <span class="amxx-function">ArrayCreate</span>(<span class="amxx-number">1</span>, <span class="amxx-symbol">numberOfCycles</span>);
	
	<span class="amxx-directive">#define</span> <span class="amxx-di">_循环访问constant</span>\
	for (<span class="amxx-symbol">counter</span> = <span class="amxx-symbol">numberOfCycles</span>; <span class="amxx-symbol">counter</span>--;)\
	{\
		<span class="amxx-symbol">counter2</span> = -<span class="amxx-number">500000</span>;\
		<span class="amxx-symbol">timer</span> = <span class="amxx-function">float</span>(<span class="amxx-function">tickcount</span>());\
		while (<span class="amxx-symbol">counter2</span>)\
		<span class="amxx-symbol">counter2</span> = <span class="amxx-symbol">counter2</span> + 1</span> + <span class="amxx-symbol">constant</span> + <span class="amxx-symbol">constant</span> + <span class="amxx-symbol">constant</span> + <span class="amxx-symbol">constant</span>;\
		<span class="amxx-function">ArrayPushCell</span>(<span class="amxx-symbol">array</span>, <span class="amxx-function">float</span>(<span class="amxx-function">tickcount</span>()) - <span class="amxx-symbol">timer</span>);\
	}
	
	if (<span class="amxx-function">equal</span>(<span class="amxx-symbol">specifier</span>, <span class="amxx-string">"enum"</span>))
	{
		enum <span class="amxx-tag">_:</span><span class="amxx-symbol">constant</span> { }	<span class="amxx-comment">// 无地址常量</span>
		<span class="amxx-di">_循环访问constant</span>
	}
	else if (<span class="amxx-function">equal</span>(<span class="amxx-symbol">specifier</span>, <span class="amxx-string">"const"</span>))
	{
		const <span class="amxx-symbol">constant</span> = <span class="amxx-number">0</span>;	<span class="amxx-comment">// 无地址常量</span>
		<span class="amxx-di">_循环访问constant</span>
	}
	else if (<span class="amxx-function">equal</span>(<span class="amxx-symbol">specifier</span>, <span class="amxx-string">"static"</span>))
	{
		static const <span class="amxx-symbol">constant</span>;	<span class="amxx-comment">// 有地址常量</span>
		<span class="amxx-di">_循环访问constant</span>
	}
	else if (<span class="amxx-function">equal</span>(<span class="amxx-symbol">specifier</span>, <span class="amxx-string">"new"</span>))
	{
		new const <span class="amxx-symbol">constant</span>;	<span class="amxx-comment">// 有地址常量</span>
		<span class="amxx-di">_循环访问constant</span>
	}
	else
	{
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]仅支持用new或static声明局部的有地址常量"</span>);
		return;
	}
	
	<span class="amxx-symbol">timer</span> = <span class="amxx-number">0.0</span>;
	for (<span class="amxx-symbol">counter</span> = <span class="amxx-symbol">numberOfCycles</span>; <span class="amxx-symbol">counter</span>--;) <span class="amxx-symbol">timer</span> += <span class="amxx-tag">Float:</span><span class="amxx-function">ArrayGetCell</span>(<span class="amxx-symbol">array</span>, <span class="amxx-symbol">counter</span>);
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]访问%s常量200万*%d次,总共消耗%.1f秒"</span>, <span class="amxx-symbol">specifier</span>, <span class="amxx-symbol">numberOfCycles</span>, <span class="amxx-symbol">timer</span> / <span class="amxx-number">1000.0</span>);
	<span class="amxx-symbol">timer</span> /= <span class="amxx-function">float</span>(<span class="amxx-symbol">numberOfCycles</span>);
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]访问%s常量,平均每200万次消耗%f毫秒"</span>, <span class="amxx-symbol">specifier</span>, <span class="amxx-symbol">timer</span>);
	
	<span class="amxx-function">ArrayDestroy</span>(<span class="amxx-symbol">array</span>);
}</code></p>

<p>测试结果会受很多因素影响,比如服务器性能,插件加载的其他代码等,所以需要多次测试.以下结果仅供参考:</p>

<p><code><span class="amxx-note">[AMXX]访问new常量200万*300次,总共消耗2.2秒
[AMXX]访问new常量,平均每200万次消耗7.650000毫秒
[AMXX]访问static常量200万*300次,总共消耗2.2秒
[AMXX]访问static常量,平均每200万次消耗7.513333毫秒
[AMXX]访问const常量200万*300次,总共消耗2.1秒
[AMXX]访问const常量,平均每200万次消耗7.139999毫秒
[AMXX]访问enum常量200万*300次,总共消耗2.1秒
[AMXX]访问enum常量,平均每200万次消耗7.099999毫秒</span></code></p>

<p>在以下代码中,由于省略了枚举标签和枚举名称,因此<span class="amxx-symbol">Eg1</span>所储存的值默认为<span class="amxx-tag">_:</span>标签.</p>

<p><span class="amxx-function">float</span>函数要求参数1带有<span class="amxx-tag">_:</span>标签,因此不会触发Tag mismatch警告(标签不匹配).</p>

<p><span class="amxx-function">floatround</span>函数要求参数1带有<span class="amxx-tag">Float:</span>标签,因此会触发Tag mismatch警告(标签不匹配).</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
public <span class="amxx-function">plugin_init</span>()
{
	enum { <span class="amxx-symbol">Eg1</span> }
	<span class="amxx-function">float</span>(<span class="amxx-symbol">Eg1</span>);
	<span class="amxx-function">floatround</span>(<span class="amxx-symbol">Eg1</span>);
}</code></p>

<p>这种省略了枚举名称的声明方式,称为匿名枚举.</p>

<p>在以下代码中,由于省略了枚举标签,因此<span class="amxx-symbol">Example Eg1 Eg2</span>所储存的值都是<span class="amxx-tag">Example:</span>标签.</p>

<p><span class="amxx-function">GetPropertyValue</span>函数要求参数1带有<span class="amxx-tag">Example:</span>标签,并根据该参数返回不同的值.</p>

<p>因此<span class="amxx-function">GetPropertyValue</span><code>(<span class="amxx-number">192</span>)</code>将会触发Tag mismatch警告(标签不匹配).</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
enum <span class="amxx-enumname">Example</span> { <span class="amxx-symbol">Eg1</span>, <span class="amxx-symbol">Eg2</span> }
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%s"</span>, <span class="amxx-function">GetPropertyValue</span>(<span class="amxx-symbol">Eg1</span>));
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%s"</span>, <span class="amxx-function">GetPropertyValue</span>(<span class="amxx-symbol">Eg2</span>));
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%s"</span>, <span class="amxx-function">GetPropertyValue</span>(<span class="amxx-symbol">Example</span>));
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%s"</span>, <span class="amxx-function">GetPropertyValue</span>(<span class="amxx-number">192</span>));
}
static <span class="amxx-function">GetPropertyValue</span>(<span class="amxx-tag">Example:</span><span class="amxx-symbol">propertyId</span>)
{
	new <span class="amxx-symbol">info</span>[<span class="amxx-number">32</span>];
	if (<span class="amxx-symbol">propertyId</span> == <span class="amxx-symbol">Eg1</span>) return <span class="amxx-symbol">info</span> = <span class="amxx-string">"身高180"</span>;
	if (<span class="amxx-symbol">propertyId</span> == <span class="amxx-symbol">Eg2</span>) return <span class="amxx-symbol">info</span> = <span class="amxx-string">"腰围180"</span>;
	if (<span class="amxx-symbol">propertyId</span> == <span class="amxx-symbol">Example</span>) return <span class="amxx-symbol">info</span> = <span class="amxx-string">"大错误"</span>;
	return <span class="amxx-symbol">info</span> = <span class="amxx-string">"极为严重的错误"</span>;
}</code></p>

<p>进入游戏载入地图后,将会在控制台看见以下四行文本:</p>

<p><code><span class="amxx-note">[AMXX]身高190
[AMXX]腰围190
[AMXX]大错误
[AMXX]极为严重的错误</span></code></p>

<p>枚举名称常常作为标签使用,用于限定自定义函数所需的参数值.</p>

<p>当开发者在使用该函数,填写枚举成员作为参数时,会得到符合预期的结果.</p>

<p>若填写无关的值,开发者在看见标签不匹配的警告后,就会意识到自己犯了错误.</p>

<p>通常只需要全文搜索该标签即可找到该枚举声明,从而知晓应该填写什么作为参数.</p>

<p>比起填写1 2 3 4等意义不明的数字,以拥有标签检查的枚举成员作为参数能让代码可读性大幅提高.</p>

<p>这也是枚举常量最实用的一点.匿名枚举不提供标签检查,会失去这一优点,几乎退化为普通的常量或宏定义.</p>

<p>某些优秀的代码编辑器会通过查询枚举标签和枚举成员,为开发者提供代码建议.</p>

<p>比如在输入参数时,弹出一个菜单,内部显示所有枚举成员作为选项,或是拥有相同标签的函数.</p>

<p>开发者能轻易找到自己想要的选项.没了枚举标签,弹出的就可能是大量无关的常量选项.</p>

<p><h2 id="click3_3">3.3:增值法</h2></p>

<p>以下代码将展示枚举声明中,增值法的使用例子.</p>

<p>增值法用于设定枚举成员的值如何增加.最常用的便是<code> <<= </code>运算符.</p>

<p><code>(<<= <span class="amxx-number">1</span>)</code>能二进制层面,让每个成员的值左移1个位,右边补一个0.</p>

<p>比如<span class="amxx-symbol">Bf_Burn</span>的值0b_0001,也就是十进制的1,左移1个位后变为0b_0010.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>
enum <span class="amxx-enumname">Buff</span> (<<= <span class="amxx-number">0b_0000_0000_0001</span>)
{
	<span class="amxx-symbol">Bf_None</span>,	<span class="amxx-comment">// 没有buff</span>
	<span class="amxx-symbol">Bf_Burn</span> = <span class="amxx-number">1</span>,	<span class="amxx-comment">// 燃烧buff</span>
	<span class="amxx-symbol">Bf_Cold</span>,	<span class="amxx-comment">// 寒冷buff</span>
	<span class="amxx-symbol">Bf_Frozen</span>,	<span class="amxx-comment">// 冻结buff</span>
	<span class="amxx-symbol">Bf_Poison</span>,	<span class="amxx-comment">// 中毒buff</span>
	<span class="amxx-symbol">Bf_Hypoxia</span>,	<span class="amxx-comment">// 缺氧buff</span>
	<span class="amxx-symbol">Bf_Blind</span>,	<span class="amxx-comment">// 失明buff</span>
	<span class="amxx-symbol">Bf_SpeedUp</span>,	<span class="amxx-comment">// 加速buff</span>
	<span class="amxx-symbol">Bf_Rage</span>,	<span class="amxx-comment">// 狂暴buff</span>
	<span class="amxx-symbol">Bf_SuperArmor</span>,	<span class="amxx-comment">// 霸体buff</span>
	<span class="amxx-symbol">Bf_MImmunity</span>,	<span class="amxx-comment">// 免疫魔法buff</span>
	<span class="amxx-symbol">Bf_PImmunity</span>,	<span class="amxx-comment">// 免疫物攻buff</span>
}
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-comment">// 注意,AMXX 1.8.2或低版本无法使用%b按照二进制形式打印文本.</span>
	
	<span class="amxx-comment">// 打印结果:	[AMXX]0000 0b_0000_0000_0000</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">Bf_None</span>, <span class="amxx-symbol">Bf_None</span>);
	<span class="amxx-comment">// 打印结果:	[AMXX]0001 0b_0000_0000_0001</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">Bf_Burn</span>, <span class="amxx-symbol">Bf_Burn</span>);
	<span class="amxx-comment">// 打印结果:	[AMXX]0002 0b_0000_0000_0010</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">Bf_Cold</span>, <span class="amxx-symbol">Bf_Cold</span>);
	<span class="amxx-comment">// 打印结果:	[AMXX]0004 0b_0000_0000_0100</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">Bf_Frozen</span>, <span class="amxx-symbol">Bf_Frozen</span>);
	<span class="amxx-comment">// 打印结果:	[AMXX]0008 0b_0000_0000_1000</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">Bf_Poison</span>, <span class="amxx-symbol">Bf_Poison</span>);
	<span class="amxx-comment">// 打印结果:	[AMXX]0016 0b_0000_0001_0000</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">Bf_Hypoxia</span>, <span class="amxx-symbol">Bf_Hypoxia</span>);
	<span class="amxx-comment">// 打印结果:	[AMXX]0032 0b_0000_0010_0000</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">Bf_Blind</span>, <span class="amxx-symbol">Bf_Blind</span>);
	<span class="amxx-comment">// 打印结果:	[AMXX]0064 0b_0000_0100_0000</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">Bf_SpeedUp</span>, <span class="amxx-symbol">Bf_SpeedUp</span>);
	<span class="amxx-comment">// 打印结果:	[AMXX]0128 0b_0000_1000_0000</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">Bf_Rage</span>, <span class="amxx-symbol">Bf_Rage</span>);
	<span class="amxx-comment">// 打印结果:	[AMXX]0256 0b_0001_0000_0000</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">Bf_SuperArmor</span>, <span class="amxx-symbol">Bf_SuperArmor</span>);
	<span class="amxx-comment">// 打印结果:	[AMXX]0512 0b_0010_0000_0000</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">Bf_MImmunity</span>, <span class="amxx-symbol">Bf_MImmunity</span>);
	<span class="amxx-comment">// 打印结果:	[AMXX]1024 0b_0100_0000_0000</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">Bf_PImmunity</span>, <span class="amxx-symbol">Bf_PImmunity</span>);
	<span class="amxx-comment">// 打印结果:	[AMXX]2048 0b_1000_0000_0000</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">Buff</span>, <span class="amxx-symbol">Buff</span>);
	
	<span class="amxx-comment">// 打印结果:	[AMXX]0011 0b_0000_0000_1011</span>
	new <span class="amxx-tag">Buff:</span><span class="amxx-symbol">IHaveMultipleBuffs</span> = <span class="amxx-symbol">Bf_Burn</span> | <span class="amxx-symbol">Bf_Cold</span> | <span class="amxx-symbol">Bf_Poison</span>;
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]%04d %012b"</span>, <span class="amxx-symbol">IHaveMultipleBuffs</span>, <span class="amxx-symbol">IHaveMultipleBuffs</span>);
}</code></p>

<p>进入游戏,载入地图后,可以看见这些枚举常量的十进制,二进制对应的数值.</p>

<p>第一个成员<span class="amxx-symbol">Bf_None</span>默认为0,除非写上初始化表达式,比如第二个成员<span class="amxx-symbol">Bf_Burn</span>被设为1,二进制是0b_0001.</p>

<p>增值法<code>(<<= <span class="amxx-number">1</span>)</code>成功使其余成员的值等于上一个成员的左移.</p>

<p>枚举名称的值等于最后一个成员的值使用增值法之后的运算结果.</p>

<p>使用<code> <<= </code>或<code> *= </code>运算符作为增值法时,需要注意,0的左移结果永远是0,0的乘法结果永远是0.</p>

<p>因此需要为某个成员初始化为任意非0值.使后续成员拥有不同的值.</p>

<p>增值法是<code>(<<= <span class="amxx-number">1</span>)</code>的枚举声明,通常也叫做二进制标志位枚举.或标志位枚举.</p>

<p>通常用于表示一个对象拥有同时拥有的多个状态.</p>

<p>比如玩家同时拥有燃烧,寒冷,中毒状态.用3个变量表示会很麻烦.</p>

<p>若使用二进制,则可以用一个变量表示32种状态(AMXX仅支持32位整数).</p>

<p>代码中的<span class="amxx-symbol">IHaveMultipleBuffs</span>是<span class="amxx-symbol">Bf_Burn</span> <span class="amxx-symbol">Bf_Cold</span> <span class="amxx-symbol">Bf_Poison</span>进行"按位或运算"的结果.</p>

<p>观察它的二进制数值,可以看见右端的1011,实际上就是<span class="amxx-symbol">Bf_Burn</span>的0001,<span class="amxx-symbol">Bf_Cold</span>的0010,<span class="amxx-symbol">Bf_Poison</span>的1000.</p>

<p>使用"按位与运算",便可确认一个变量或常量是否含有某个位:</p>

<p><code>if (<span class="amxx-symbol">IHaveMultipleBuffs</span> & <span class="amxx-symbol">Bf_Burn</span>)
{
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]IHaveMultipleBuffs含有Bf_Burn"</span>)
}
else
{
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]IHaveMultipleBuffs不含有Bf_Burn"</span>)
}</code></p>

<p>使用"按位或运算",便可添加状态(按照或运算的特性,已有状态不会重复添加):</p>

<p><code><span class="amxx-symbol">IHaveMultipleBuffs</span> |= <span class="amxx-symbol">Bf_MImmunity</span>;
<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]变量IHaveMultipleBuffs添加了(魔法免疫)状态"</span>);

<span class="amxx-symbol">IHaveMultipleBuffs</span> |= <span class="amxx-symbol">Bf_Burn</span> | <span class="amxx-symbol">Bf_Cold</span> | <span class="amxx-symbol">Bf_Poison</span>;
<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]变量IHaveMultipleBuffs添加了(燃烧,寒冷,剧毒)状态"</span>);</code></p>

<p>使用"按位或运算"和"按位取反",便可删除状态(按照或运算的特性,不会重复删除不存在的状态):</p>

<p><code><span class="amxx-symbol">IHaveMultipleBuffs</span> &= ~<span class="amxx-symbol">Bf_MImmunity</span>;
<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]变量IHaveMultipleBuffs删除了Bf_MImmunity(魔法免疫)状态"</span>);

<span class="amxx-symbol">IHaveMultipleBuffs</span> &= ~(<span class="amxx-symbol">Bf_Burn</span> | <span class="amxx-symbol">Bf_Cold</span> | <span class="amxx-symbol">Bf_Poison</span>);
<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]变量IHaveMultipleBuffs删除了(燃烧,寒冷,剧毒)状态"</span>);</code></p>

<p>匿名枚举同样可以设定增值法.但失去了标签检查,会让开发者或第三方使用者产生疑惑.</p>

<p>可能会不小心给变量添加或删除无关的二进制数值.</p>

<p>某些优秀的代码编辑器会通过查询枚举标签和枚举成员,为开发者提供代码建议.</p>

<p>比如在输入<code> &= </code>之后,弹出一个菜单,内部显示所有枚举成员作为选项,或是拥有相同标签的函数.</p>

<p>开发者能轻易找到自己想要的选项.没了枚举标签,弹出的就可能是大量无关的常量选项.</p>

<p>AMXX的头文件中有大量反面教材,各种宏定义常量,比如CSW_*系列常量,ADMIN_*系列常量.各种匿名枚举,比如print_*系列常量.</p>

<p>它们都是默认使用_:标签,相关函数的返回值,函数的参数,统统使用_:标签.</p>

<p>函数注释又写得简略,即便填写了无关的数值也没有警告,给开发者带来各种困扰.</p>

<p>应当善加利用枚举名称,标签检查可大幅度降低查找问题的时间.</p>

<p><h2 id="click3_4">3.4:元素标签</h2></p>

<p>定义数组容量或用索引访问元素时,索引与容量的标签必须一致.</p>

<p>枚举成员的元素标签是为数组服务的.此时整个枚举声明可以视作枚举结构体.</p>

<p>在以下代码中,这些拥有元素标签的枚举成员将改变编译器对数组元素的标签判断.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>

enum
{
	<span class="amxx-tag">Float:</span>	<span class="amxx-symbol">Eg1_float</span>,	<span class="amxx-comment">// Eg1_float在增值法作用下,存有常量0</span>
	<span class="amxx-tag">Array:</span>	<span class="amxx-symbol">Eg2_array</span>,	<span class="amxx-comment">// Eg2_array在增值法作用下,存有常量1</span>
}

stock <span class="amxx-symbol">gArray1</span>[<span class="amxx-number">2</span>];	<span class="amxx-comment">// 声明整数型数组</span>
stock <span class="amxx-tag">Float:</span><span class="amxx-symbol">gValueFloat</span>, <span class="amxx-tag">Array:</span><span class="amxx-symbol">gValueArray</span>;

public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-comment">// 将0号元素赋值为浮点数512.5,会被编译器警告:标签不匹配.因为gArray1是整数型数组</span>
	<span class="amxx-symbol">gArray1</span>[<span class="amxx-number">0</span>]		= <span class="amxx-number">512.5</span>;
	<span class="amxx-comment">// 用Eg1_float代替0号索引,不被警告.因为Eg1_float带有元素标签Float:</span>
	<span class="amxx-symbol">gArray1</span>[<span class="amxx-symbol">Eg1_float</span>]	= <span class="amxx-number">512.5</span>;
	
	<span class="amxx-comment">// 将1号元素赋值为Invalid_Array,会被编译器警告:标签不匹配.因为gArray1是整数型数组</span>
	<span class="amxx-symbol">gArray1</span>[<span class="amxx-number">1</span>]		= <span class="amxx-symbol">Invalid_Array</span>;
	<span class="amxx-comment">// 用Eg2_array代替1号索引,不被警告.因为Eg2_array带有元素标签Array:</span>
	<span class="amxx-symbol">gArray1</span>[<span class="amxx-symbol">Eg2_array</span>]	= <span class="amxx-symbol">Invalid_Array</span>;
	
	<span class="amxx-comment">// 注:Invalid_Array是一个拥有Array:标签的常量.</span>
	<span class="amxx-comment">// 注:AMXX1.8.2或低版本有bug.因此,上面元素的赋值表达式依然会被警告</span>
	
	<span class="amxx-comment">// 用浮点型变量储存0号元素值,会被编译器警告.因为gArray1是整数型数组</span>
	<span class="amxx-symbol">gValueFloat</span>	= <span class="amxx-symbol">gArray1</span>[<span class="amxx-number">0</span>];
	<span class="amxx-comment">// 用Eg1_float代替0号索引,不被警告.因为Eg1_float带有元素标签Float:</span>
	<span class="amxx-symbol">gValueFloat</span>	= <span class="amxx-symbol">gArray1</span>[<span class="amxx-symbol">Eg1_float</span>];
	
	<span class="amxx-comment">// 用Array型变量储存1号元素值,会被编译器警告.因为gArray1是整数型数组</span>
	<span class="amxx-symbol">gValueArray</span>	= <span class="amxx-symbol">gArray1</span>[<span class="amxx-number">1</span>];
	<span class="amxx-comment">// 用Eg2_array代替1号索引,不被警告.因为Eg2_array带有元素标签Array:</span>
	<span class="amxx-symbol">gValueArray</span>	= <span class="amxx-symbol">gArray1</span>[<span class="amxx-symbol">Eg2_array</span>];
}</code></p>

<p>元素标签可让数组储存多种不同类型的元素数值.</p>

<p>如果要存取一个对象的多种不同类型数据,</p>

<p>比起声明多个不同类型的变量用于存取,这种方法会更加方便.</p>

<p>元素标签通常应该与枚举名称一起使用.匿名枚举只能影响访问时的标签检查.</p>

<p>将枚举名称作为容量使用,数组初始化时也能设定不同类型的元素值.如下所示:</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>

enum <span class="amxx-enumname">Example</span>
{
	<span class="amxx-tag">Float:</span>	<span class="amxx-symbol">Eg1_float</span>,
	<span class="amxx-tag">Array:</span>	<span class="amxx-symbol">Eg2_array</span>,
}

<span class="amxx-comment">// 不被警告.编译器承认其内2个元素使用Float:与Array:标签</span>
stock <span class="amxx-symbol">gArray1</span>[<span class="amxx-enumname">Example</span>] = { <span class="amxx-number">5.55</span>, <span class="amxx-symbol">Invalid_Array</span> };
<span class="amxx-comment">// 触发2个警告,编译器认为其内2个元素应使用_:标签</span>
stock <span class="amxx-symbol">gArray2</span>[<span class="amxx-number">2</span>] = { <span class="amxx-number">5.55</span>, <span class="amxx-symbol">Invalid_Array</span> };

<span class="amxx-comment">// 无关内容:</span>
public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]gArray1 = [ %.2f, %d ]"</span>, <span class="amxx-symbol">gArray1</span>[<span class="amxx-symbol">Eg1_float</span>], <span class="amxx-symbol">gArray1</span>[<span class="amxx-symbol">Eg2_array</span>]);
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]gArray2 = [ %.2f, %d ]"</span>, <span class="amxx-symbol">gArray2</span>[<span class="amxx-number">0</span>], <span class="amxx-symbol">gArray2</span>[<span class="amxx-number">1</span>]);
}</code></p>

<p>声明数组时将枚举名称作为容量,开发者或第三方人员在访问元素时,会自然而然的去查阅并使用相关枚举成员.</p>

<p>填写无关的数值作为索引,会触发警告.使访问者在编译时意识到自己的错误,这减少了运行时出错的概率.</p>

<p>AMXX的头文件中有大量反面教材,各种宏定义常量,比如<span class="amxx-symbol">CSW_*</span>系列常量,<span class="amxx-symbol">ADMIN_*</span>系列常量.各种匿名枚举,比如<span class="amxx-symbol">print_*</span>系列常量.</p>

<p>它们都是默认使用<span class="amxx-tag">_:</span>标签,相关函数的返回值,函数的参数,统统使用<span class="amxx-tag">_:</span>标签.</p>

<p>函数注释又写得简略,即便填写了无关的数值也没有警告,给开发者带来各种困扰.</p>

<p>应当善加利用枚举名称,标签检查可大幅度降低查找问题的时间.</p>

<p>注:</p>

<p>匿名枚举中,枚举常量默认带有<span class="amxx-tag">_:</span>标签,拥有枚举名称之后,枚举常量带有<span class="amxx-tag">Example:</span>标签.</p>

<p>数组容量与元素索引的标签不同将会触发警告:</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>

enum <span class="amxx-enumname">Example</span>
{
	<span class="amxx-tag">Float:</span>	<span class="amxx-symbol">Eg1_float</span>,
	<span class="amxx-tag">Array:</span>	<span class="amxx-symbol">Eg2_array</span>,
}

<span class="amxx-comment">// 容量的标签被省略时,默认为_:标签</span>
stock <span class="amxx-symbol">gArray1</span>[<span class="amxx-number">2</span>];
<span class="amxx-comment">// 以Example:作为容量标签(注:初始化触发2个警告.或许是bug,或者,强制更改2的标签本身属于违规行为,正常应该直接填写Example而不是Example:2)</span>
stock <span class="amxx-symbol">gArray2</span>[<span class="amxx-tag">Example:</span><span class="amxx-number">2</span>] = { <span class="amxx-number">5.5</span>, <span class="amxx-symbol">Invalid_Array</span> };

public <span class="amxx-function">plugin_init</span>()
{
	<span class="amxx-comment">// 被警告,因为gArray1的容量标签是_:</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]gArray1[0] = %.2f"</span>, <span class="amxx-symbol">gArray1</span>[<span class="amxx-symbol">Eg1_float</span>]);
	<span class="amxx-comment">// 不被警告,因为gArray2的容量标签是Example:</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]gArray2[0] = %d"</span>, <span class="amxx-symbol">gArray2</span>[<span class="amxx-symbol">Eg2_array</span>]);
}</code></p>

<p><h2 id="click3_5">3.5:枚举成员名称</h2></p>

<p>枚举成员与枚举名称一样,是无地址的常量.遵从标识符的命名规则.</p>

<p>命名后时应该自行检查,是否有多个成员重名.编译器不作检查.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>

<span class="amxx-comment">// 多个成员重名,不会被警告或触发报错</span>
enum <span class="amxx-enumname">Example1</span>
{
	<span class="amxx-symbol">Eg1</span>,
	<span class="amxx-symbol">Eg1</span>,
	<span class="amxx-symbol">Eg1</span>,
	<span class="amxx-symbol">Eg1</span>,
}

<span class="amxx-comment">// 与其它枚举的成员重名,不会被警告或触发报错</span>
enum <span class="amxx-enumname">Example2</span>
{
	<span class="amxx-symbol">Eg1</span>,
	<span class="amxx-symbol">Eg1</span>,
	<span class="amxx-symbol">Eg1</span>,
	<span class="amxx-symbol">Eg1</span>,
}

<span class="amxx-comment">// 无关内容:</span>
public <span class="amxx-function">plugin_init</span>() { }</code></p>

<p><h2 id="click3_6">3.6:元素尺寸</h2></p>

<p>枚举成员的元素尺寸是为数组服务的.此时整个枚举声明可以视作枚举结构体.</p>

<p>在以下代码中,这些拥有元素尺寸的枚举成员,能将数组多个数据整合为1个块,视作1个元素.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>

<span class="amxx-comment">// 枚举结构体:设定"人"的数据结构</span>
enum <span class="amxx-enumname">CPeople</span>
{
	<span class="amxx-symbol">CPName</span>[<span class="amxx-number">32</span>],		<span class="amxx-comment">// 数组用中32个元素表示"人"的姓名</span>
	<span class="amxx-symbol">CPBirthDate</span>[<span class="amxx-number">32</span>],	<span class="amxx-comment">// 数组用中32个元素表示"人"的出生日期</span>
	<span class="amxx-symbol">CPGender</span>[<span class="amxx-number">16</span>],		<span class="amxx-comment">// 数组用中16个元素表示"人"的性别</span>
	<span class="amxx-symbol">CPHeight</span>[<span class="amxx-number">22</span>],		<span class="amxx-comment">// 数组用中22个元素表示"人"的身高</span>
	<span class="amxx-symbol">CPWeight</span>[<span class="amxx-number">22</span>],		<span class="amxx-comment">// 数组用中22个元素表示"人"的体重</span>
}

public <span class="amxx-function">plugin_init</span>()
{
	new <span class="amxx-symbol">people</span>[<span class="amxx-enumname">CPeople</span>] = { <span class="amxx-string">"李华"</span>, <span class="amxx-string">"9:56 2023/9/23"</span>, <span class="amxx-string">"武装直升机"</span>, <span class="amxx-string">"3米"</span>, <span class="amxx-string">"5000公斤"</span> };
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]某人的姓名:%s"</span>, <span class="amxx-symbol">people</span>[<span class="amxx-symbol">CPName</span>]);
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]某人的出生日期:%s"</span>, <span class="amxx-symbol">people</span>[<span class="amxx-symbol">CPBirthDate</span>]);
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]某人的性别:%s"</span>, <span class="amxx-symbol">people</span>[<span class="amxx-symbol">CPGender</span>]);
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]某人的身高:%s"</span>, <span class="amxx-symbol">people</span>[<span class="amxx-symbol">CPHeight</span>]);
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]某人的体重:%s"</span>, <span class="amxx-symbol">people</span>[<span class="amxx-symbol">CPWeight</span>]);
}</code></p>

<p>以上代码看起来像是把一维数组<span class="amxx-symbol">people</span>升维至二维数组.但那只是表象.</p>

<p>从第2个枚举成员开始,每个成员的值等于上一个成员的值+元素尺寸.</p>

<p><span class="amxx-symbol">CPName</span>的值是0,元素尺寸是32,因此<span class="amxx-symbol">CPBirthDate</span>的值是0+32.</p>

<p>如此一来枚举名称<span class="amxx-symbol">CPeople</span>的值为32+32+16+22+22,即124.而<code>new <span class="amxx-symbol">people</span>[<span class="amxx-enumname">CPeople</span>]</code>实际上是声明了尺寸为124的一维数组.</p>

<p>枚举名称作为数组的容量使用,能够改变数组初始化表达式的数据分配规则.</p>

<p><span class="amxx-symbol">people</span>数组的0至31号元素被用于储存<span class="amxx-string">"李华"</span>.</p>

<p><span class="amxx-symbol">people</span>数组的32至63号元素被用于储存<span class="amxx-string">"9:56 2023/9/23"</span>.</p>

<p><span class="amxx-symbol">people</span>数组的64至79号元素被用于储存<span class="amxx-string">"武装直升机"</span>.</p>

<p><span class="amxx-symbol">people</span>数组的80至101号元素被用于储存<span class="amxx-string">"3米"</span>.</p>

<p><span class="amxx-symbol">people</span>数组的102至123号元素被用于储存<span class="amxx-string">"5000公斤"</span>.</p>

<p>虽然<span class="amxx-symbol">people</span>数组中依然拥有124个元素,但用枚举成员作为索引访问<span class="amxx-symbol">people</span>数组时,可以将<span class="amxx-symbol">people</span>数组视作拥有5个元素.</p>

<p>这种情况下,枚举成员的元素尺寸,实际上就是这5个元素的尺寸.</p>

<p>若字符串的字节数超过设定的元素尺寸,会覆盖下一个元素的储存空间.</p>

<p>若字符串的字节数小于元素尺寸,多出来的部分全部默认储存0.</p>

<p><span class="amxx-symbol">people</span>数组能表现出二维数组的特性,可以拥有2对方括号.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>

<span class="amxx-comment">// 枚举结构体:设定"数组包"的数据结构</span>
enum <span class="amxx-enumname">CArray</span>
{
	<span class="amxx-symbol">CA1</span>,		<span class="amxx-comment">// 数组用中1个元素表示"数组包"的第1个包</span>
	<span class="amxx-symbol">CA2</span>[<span class="amxx-number">1</span>],		<span class="amxx-comment">// 数组用中1个元素表示"数组包"的第2个包</span>
	<span class="amxx-symbol">CA3</span>[<span class="amxx-number">2</span>],		<span class="amxx-comment">// 数组用中2个元素表示"数组包"的第3个包</span>
	<span class="amxx-symbol">CA4</span>[<span class="amxx-number">3</span>],		<span class="amxx-comment">// 数组用中3个元素表示"数组包"的第4个包</span>
}

public <span class="amxx-function">plugin_init</span>()
{
	new <span class="amxx-symbol">array</span>[<span class="amxx-enumname">CArray</span>] = { <span class="amxx-number">1</span>, <span class="amxx-number">2</span>, { <span class="amxx-number">3</span>, <span class="amxx-number">4</span> }, <span class="amxx-string">"56"</span> };
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]CA1数组包的值:%d"</span>, <span class="amxx-symbol">array</span>[<span class="amxx-symbol">CA1</span>]);						<span class="amxx-comment">// 元素尺寸小于2,表现为单值</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]CA2数组包的值:[ %d ]"</span>, <span class="amxx-symbol">array</span>[<span class="amxx-symbol">CA2</span>]);						<span class="amxx-comment">// 元素尺寸小于2,表现为单值</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]CA3数组包的值:[ %d, %d ]"</span>, <span class="amxx-symbol">array</span>[<span class="amxx-symbol">CA3</span>][<span class="amxx-number">0</span>], <span class="amxx-symbol">array</span>[<span class="amxx-symbol">CA3</span>][<span class="amxx-number">1</span>]);			<span class="amxx-comment">// 元素尺寸大于1,表现为二维数组</span>
	<span class="amxx-function">server_print</span>(<span class="amxx-string">"[AMXX]CA4数组包的值:[ %c, %c, %d ]"</span>, <span class="amxx-symbol">array</span>[<span class="amxx-symbol">CA4</span>][<span class="amxx-number">0</span>], <span class="amxx-symbol">array</span>[<span class="amxx-symbol">CA4</span>][<span class="amxx-number">1</span>], <span class="amxx-symbol">array</span>[<span class="amxx-symbol">CA4</span>][<span class="amxx-number">2</span>]);	<span class="amxx-comment">// 元素尺寸大于1,表现为二维数组</span>
}</code></p>

<p>打印结果为:</p>

<p><code><span class="amxx-note">[AMXX]CA1数组包的值:1
[AMXX]CA2数组包的值:[ 2 ]
[AMXX]CA3数组包的值:[ 3, 4 ]
[AMXX]CA4数组包的值:[ 5, 6, 0 ]</span></code></p>

<p><h2 id="click3_7">3.7:初始化表达式</h2></p>

<p>正常情况下由增值法对枚举成员和枚举名称进行初始化.</p>

<p>增值法设定的常量值是规律的.若需要一些不规律的常量值,便可用初始化表达式来设置.</p>

<p>表达式中不能有浮点数,数组,字符串这类字面量.</p>

<p>float.inc提供了浮点数运算符的重载,大部分运算符都被替换成运行时函数.</p>

<p>因此,编译器无法在编译时确定浮点数相关的运算结果.</p>

<p><code><span class="amxx-directive">#include</span> <span class="amxx-string">amxmodx</span>

enum <span class="amxx-enumname">Example</span>
{
	<span class="amxx-symbol">Eg1</span> = <span class="amxx-number">1024</span>,	<span class="amxx-comment">// 可行的,无警告或报错</span>
	<span class="amxx-symbol">Eg2</span> = <span class="amxx-number">0b10</span>,	<span class="amxx-comment">// 可行的,无警告或报错</span>
	<span class="amxx-symbol">Eg3</span> = <span class="amxx-number">0x1F</span>,	<span class="amxx-comment">// 可行的,无警告或报错</span>
	<span class="amxx-symbol">Eg4</span> = <span class="amxx-number">3.5</span>,	<span class="amxx-comment">// 可行的,无警告或报错(枚举体内无标签检查),浮点数自动转变为指针1080033280</span>
	<span class="amxx-symbol">Eg5</span> = <span class="amxx-tag">_:</span><span class="amxx-number">5.0</span>,	<span class="amxx-comment">// 可行的,无警告或报错,浮点数手动转变为指针1084227584</span>
	<span class="amxx-symbol">Eg6</span> = <span class="amxx-tag">_:</span><span class="amxx-number">1.5</span> + <span class="amxx-number">5</span>,<span class="amxx-comment">// 得到1069547525</span>
	<span class="amxx-symbol">Eg7</span> = <span class="amxx-number">1</span> + <span class="amxx-number">2.0</span>,	<span class="amxx-comment">// 报错,浮点运算无法在编译时进行</span>
	<span class="amxx-symbol">Eg8</span> = <span class="amxx-number">1.0</span> + <span class="amxx-number">5</span>,	<span class="amxx-comment">// 报错,浮点运算无法在编译时运行</span>
}

<span class="amxx-comment">// 无关内容:</span>
public <span class="amxx-function">plugin_init</span>() { }</code></p>

<p>名称成员储存的值拥有什么标签,由枚举标签决定.</p>

<p>如果没有枚举标签,则使用枚举名称作为标签.</p>

<p>如果也没有枚举名称,则默认使用<span class="amxx-tag">_:</span>作为标签.</p>

<p>具体参考枚举标签和枚举名称的介绍.</p>

</body>
</html>